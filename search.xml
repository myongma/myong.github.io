<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git提交历史查询功能介绍以及使用]]></title>
    <url>%2F20191014%2FGit%E6%8F%90%E4%BA%A4%E5%8E%86%E5%8F%B2%E6%9F%A5%E8%AF%A2%E5%8A%9F%E8%83%BD%E4%BB%8B%E7%BB%8D%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[记录一次由项目代码出现冲突，被覆盖引发的log查询追溯，随便根据互联网大佬们提供的方法整理git中log使用技巧 1git log 查询整个项目提交的commit history，如下所示： 123456789101112$ git logcommit bd67a7478bf06cfaed559f04d69bb26da676e870 (HEAD -&gt; master, origin/master)Author: Mr.Yong &lt;1650464351@qq.com&gt;Date: Mon Oct 14 15:43:15 2019 +0800 新增博文数据库备份commit d74f38379d7f267484883f5c18ef37674354573eAuthor: Mr.Yong &lt;1650464351@qq.com&gt;Date: Mon Oct 14 14:28:43 2019 +0800 修改readme git log默认输出 commit hash, author, date, commit message 本文主要介绍查找指定文件的提交记录，git log参数本文不做介绍 查询指定文件的提交记录 12345678910111213git log -- &lt;file&gt;#说明 指定文件名#如下$ git log -- _config.ymlcommit 20366999302a9e9ade68472fe8bcdc5478f49334Author: Mr.Yong &lt;1650464351@qq.com&gt;Date: Mon Oct 14 00:26:54 2019 +0800 修改配置commit 65e6ea25940666d037eab765cb5020f2b488cb40Author: Mr.Yong &lt;1650464351@qq.com&gt;Date: Wed Oct 2 12:36:01 2019 +0800 初始化项目 比较每次提交的内容差异 12345678910111213141516171819202122232425git log -p -2 -- &lt;file&gt;#说明：-p 提交内容差异，-2显示最近两次更新#如下$ git log -p -2 -- _config.ymlcommit 20366999302a9e9ade68472fe8bcdc5478f49334Author: Mr.Yong &lt;1650464351@qq.com&gt;Date: Mon Oct 14 00:26:54 2019 +0800 修改配置diff --git a/_config.yml b/_config.ymlindex 8bf62e4..b567a60 100644--- a/_config.yml+++ b/_config.yml@@ -4,9 +4,9 @@ # Site title: Mr.Yong-subtitle:+subtitle: 一个专注技术分享的小哥哥 description: 生活，不止眼前的苟且，还有诗和远方-keywords:+keywords: 博客,个人博客,博客模板,博客系统,网站制作,个人博客网站,it博客,个人网站,优秀的个人网站,php,程序员,互联网,thinkphp,layui,前端,后端,WEB,HTML,HTML5,CSS,CSS2.javascript,响应式 author: Mr.Yong language: zh-CN 图形化查看提交历史 12gitk -- &lt;file&gt;#说明 随 Git 一同发布的 gitk 就是这样一种工具。它是用 Tcl/Tk 写成的，基本上相当于 git log 命令的可视化版本，凡是 git log 可以用的选项也都能用在 gitk 上。 参考 gitlog 查看指定文件的提交记录]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python与mysqldump的数据库备份]]></title>
    <url>%2F20191014%2FPython%E4%B8%8Emysqldump%E7%9A%84%E6%95%B0%E6%8D%AE%E5%BA%93%E5%A4%87%E4%BB%BD.html</url>
    <content type="text"><![CDATA[准备所需的库：os,zipfile,re,datetime 功能1、根据配置文件生成数据库备份压缩文件 2、根据配置的过期时间（天）清理过期压缩文件 介绍mysqldump是备份MySQL数据库的一种好工具。它相对于用phpmyadmin等备份工具更加快速，又避免受php.ini等的限制，在windows系统下还可以结合计划任务实现定时远程备份数据库。 mysqldump命令的一些用法： 1、将整个数据库以及建表文件导出到sql文件中 1mysqldump -uroot -proot database1 &gt; database1.sql 2.将sql文件的数据导入,不再是mysqldump,而是mysql 1mysql -uroot -proot database2 &lt; database1.sql 3.将数据库中的某个表的数据及结构导出到sql文件中 1mysqldump -uroot -proot database1 tablename &gt; table1.sql 4..将sql文件的数据导入,不再是mysqldump,而是mysql 1mysql -uroot -proot database1 &lt; database1.sql 5.mysql 数据迁移命令 备份database库table表中id大于22的数据，SQL如下 1mysqldump -utest -ptest database table --default-character-set=utf8 -t --where="id&gt;22" &gt;c:\test.sql 代码实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134#!/usr/bin/env python# -*- encoding: utf-8 -*-'''@File : backupMySQL.py@Time : 2019/10/12 14:48:49@Author : MrYong @Version : 1.0@Contact : m.yong@foxmail.com@License : (C)Copyright 2018-2019, MR YONG@Desc : None'''# here put the import libimport os,zipfile,refrom datetime import date, datetimeclass BackupMySQL(object): def __init__(self, options): ''' 初始化配置信息，mysql链接信息，备份文件保存信息 ''' self.host = options['host'] if "host" in options.keys() else 'localhost' if 'db_name' not in options.keys(): print('请设置数据库名称') return self.db_name = options['db_name'] if 'db_user_name' not in options.keys(): print('请设置数据库用户名') return self.db_user_name = options['db_user_name'] if 'db_user_pwd' not in options.keys(): print('请设置数据库密码') return self.db_user_pwd = options['db_user_pwd'] self.port = options['port'] if 'port' in options.keys() else 3306 self.mysql_dump_exe = options['mysql_dump_exe'] if 'mysql_dump_exe' in options.keys() else '"D:\\MySQL\\MySQL Server 5.7\\bin\\mysqldump.exe"' self.backup_dir = options['backup_dir'] if 'backup_dir' in options.keys() else 'D:\\dataBaseBackup' self.max_clear_days = options['max_clear_days'] if 'max_clear_days' in options.keys() else 15 self.init() def init(self): ''' 备份目录创建 文件名称生成 ''' #备份目录不存在创建 if not os.path.exists(self.backup_dir): os.makedirs(self.backup_dir) #生成备份文件名称 today_date = date.today().strftime('%Y-%m-%d') self.file_name = today_date + '.sql' self.zip_file_name = today_date + '.zip' def search_file(self, pattern): ''' 列出备份文件目录 ''' file_lsit = [] with os.scandir(self.backup_dir) as files: for file in files: if not file.name.startswith('.') and file.is_file(): if re.fullmatch(pattern, file.name): file_lsit.append(file.name) return file_lsit def clear_file(self): ''' 清理max_clear_days的过期文件 ''' files = self.search_file(r'\d&#123;4&#125;-\d&#123;2&#125;-\d&#123;2&#125;.zip') for file in files: file_date = file.split('.')[0] time = datetime.strptime(file_date, '%Y-%m-%d') days = (datetime.today() - time).days if days &gt; self.max_clear_days: print('正在删除文件：%s'%file) os.remove(self.backup_dir + '\\' + file) print('清理完成') def run(self): ''' 数据库备份执行 ''' #切换到备份目录 os.chdir(self.backup_dir) #生成备份数据库命令 run_backup = '%s --host=%s --user=%s --password=%s --protocol=tcp --port=%s --default-character-set=utf8 %s &gt; %s'%( self.mysql_dump_exe, self.host, self.db_user_name, self.db_user_pwd, self.port, self.db_name, self.file_name ) print(run_backup) os.system(run_backup) self.save_file() def save_file(self): ''' 保存为压缩文件 ''' if os.path.exists(self.file_name): with zipfile.ZipFile(self.zip_file_name, 'w', zipfile.ZIP_DEFLATED) as zp: zp.write(self.file_name) os.remove(self.file_name) print('备份数据库成功')if __name__ == "__main__": options = &#123; 'host':'127.0.0.1', 'db_name' :'test', 'db_user_name' :'root', 'db_user_pwd' :'root', 'max_clear_days':30, &#125; backup = BackupMySQL(options) #执行备份 backup.run() #执行清理 #backup.clear_file()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>Mysql</tag>
        <tag>数据库备份</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[内网使用Composer]]></title>
    <url>%2F20191008%2F%E5%86%85%E7%BD%91%E4%BD%BF%E7%94%A8Composer.html</url>
    <content type="text"><![CDATA[最近本地部署Laravel开发环境时，遇到公司的内网无法正常使用Composer下载Laravel，后来发现是要设置公司内网代理 1、安装Composer正常在官网下载，傻瓜式安装即可 2、设置代理在环境变量中新增如下： 在cmd中运行如下代码： 12set http_proxy=http://web-proxy.tencent.com:8080set https_proxy=http://web-proxy.tencent.com:8080 3、测试代理12echo %http_proxy%echo %https_proxy% 4、用composer拉取1composer create-project --prefer-dist laravel/laravel laravel 大功告成]]></content>
      <tags>
        <tag>Composer</tag>
        <tag>内网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP回调函数call_user_func和call_user_func_array使用]]></title>
    <url>%2F20190723%2FPHP%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0call_user_func%E5%92%8Ccall_user_func_array%E4%BD%BF%E7%94%A8.html</url>
    <content type="text"><![CDATA[最近将项目的php版本从5.6升级到7.1+后，由于php5中的部分功能在php7中不能使用，比如如下代码$db-&gt;$vals[0]($vals[1]),在php5中可以正常使用，php7中就不能使用了，于是将其代码改为了call_user_func_array(array($db, $vals[0]), $vals[1])进行调用，完美兼容php5和php7. 以下是call_user_func和call_user_func_array方法的使用方法介绍1call_user_func($func); 调用一个回调函数处理字符串, 可以用匿名函数，可以用有名函数，可以传递类的方法， 用有名函数时，只需传函数的名称 用类的方法时，要传类的名称和方法名 传递的第一个参数必须为函数名，或者匿名函数，或者方法 其他参数，可传一个参数，或者多个参数，这些参数会自动传递到回调函数中 而回调函数，可以通过传参，获取这些参数 返回回调函数处理后的结果 1、调用普通函数 12345678910//先引用后增加function a($b)&#123; echo $b + 1;&#125;call_user_func('a', 1);#结果显示2//先增加后引用call_user_func(function($b)&#123; echo $b + 1;&#125;, 1);#传给匿名函数的参数为1，执行的结果为2 2、调用类的方法(包括类的静态方法和实例对象方法) 123456789101112131415161718//1、调用没有命名空间的类的方法class A()&#123; public function bb($a)&#123; echo $a + 1; &#125; public static function cc($i)&#123; echo $i + 2; &#125;&#125;//实例对象后调用$obj = new A;call_user_func(array($obj, 'bb'), 1);//显示2//静态方法使用如下方法调用call_user_func(array('A', 'cc'), 1);//或call_user_func('A::cc', 1); 12345678910111213141516171819//2、调用有命名空间的类的方法namespace Demo;class A()&#123; public function _func()&#123; print_r(func_get_args());//打印函数的参数 &#125; public static function cc($i)&#123; echo $i + 2; &#125;&#125;//针对普通方法$obj = new \Demo\A;call_user_func(array($obj, '_func'), 'a', 1, 2, 'b');//针对静态方法，两种调用方式//1、可以用array(__NAMESPACE__.'\类名','方法名')传递类方法，也就是：array('命名空间\类名','方法名')call_user_func(array(__NAMESPACE__.'\A','cc'), 10);//2、也可以用__NAMESPACE__.'\类名::方法名' ···传递类方法，也就是：'命名空间\类名::方法名'call_user_func('Demo\A::cc', 10); call_user_func_array函数和call_user_func很相似，只不过是换了一种方式传递了参数，让参数的结构更清晰 1call_user_func_array($func, $arr); 1、简单函数方法调用 1234function a($a, $b)&#123; echo $a + $b + 10;&#125;call_user_func_array('a', array(1, 2));//13 2、调用类的方法 1234567891011121314151617//无命名空间的类方法调用class A()&#123; public function bb($a, $c)&#123; echo $a + $c + 10; &#125; public static function cc($a, $b)&#123; echo $a + $b + 20; &#125;&#125;//非静态方法$obj = new A;call_user_func_array(array($obj, 'bb'), array(1, 3));//14//静态方法调用call_user_func_array(array('A', 'bb'), array(1, 3));//或call_user_func_array('A::cc', array(2, 5));//27 123456789101112131415161718//有命名空间的类方法调用namespace Demo;class A()&#123; public function bb($a, $c)&#123; echo $a + $c + 10; &#125; public static function cc($a, $b)&#123; echo $a + $b + 20; &#125;&#125;//非静态方法$obj = new A;call_user_func_array(array($obj, 'bb'), array(1, 3));//14//静态方法调用call_user_func_array(array('\Demo\A', 'bb'), array(1, 3));//或call_user_func_array('\Demo\A::cc', array(2, 5));//27 请注意，传入call_user_func()和call_user_func_array()的参数不能为引用传递]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[解决Nginx自动忽略header包含下划线参数方法]]></title>
    <url>%2F20190705%2F%E8%A7%A3%E5%86%B3Nginx%E8%87%AA%E5%8A%A8%E5%BF%BD%E7%95%A5header%E5%8C%85%E5%90%AB%E4%B8%8B%E5%88%92%E7%BA%BF%E5%8F%82%E6%95%B0%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[最近更换了站点的服务器，web服务环境使用了LNMP（之前使用的是LAMP），在部署项目时发现后端无法获取http请求头中的自定义参数。 原因： nginx对http请求header name的字符做了限制，默认 underscores_in_headers 为off表示如果header name中包含下划线，则忽略掉，部署后就获取不到。 解决方法： 1.在自定义的header信息里不要用下划线，可以用驼峰命名或者其他的符号（如减号-）代替. 2.在nginx里的 nginx.conf文件中配置http的部分添加 ： underscores_in_headers on;（默认值是off） 建议使用第一种方法，nginx有这种限制肯定有原因的。 是因为nginx是严格按照http 的标准，头部是不允许出现下划线，所以nginx直接舍弃了带下划线的参数。]]></content>
      <categories>
        <category>Nginx</category>
      </categories>
      <tags>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii2安装使用InfluxDB]]></title>
    <url>%2F20190523%2FYii2%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8InfluxDB.html</url>
    <content type="text"><![CDATA[1、安装influxdb-php在项目中打开cmder，执行如下命令，电脑必须安装了composer1composer require influxdb/influxdb-php 2、简单的操作创建链接对象方式一1$client = new InfluxDB\Client($host, $port); 方式二12$database = InfluxDB\Client::fromDSN(sprintf('influxdb://user:pass@%s:%s/%s', $host, $port, $dbname));$client = $database-&gt;getClient(); 设置查询数据库1$database = $client-&gt;selectDB('testdb'); 执行查询语句1$result = $database-&gt;query('select * from test LIMIT 5'); 将结果集转成一个数组1$points = $result-&gt;getPoints(); 可以使用getQueryBuilder简化查询123456789101112$result = $database-&gt;getQueryBuilder() -&gt;select('cpucount') -&gt;from('test') -&gt;limit(2) -&gt;offset(2) -&gt;getResultSet() -&gt;getPoints();$query = $database-&gt;getQueryBuilder() -&gt;select('cpucount') -&gt;from('test') -&gt;where(["region = 'us-west'"]) -&gt;getQuery(); 添加数据1234567891011121314151617$points = array( new Point( 'test', // name of the measurement 0.64, // the measurement value ['host' =&gt; 'server01', 'region' =&gt; 'us-west'], // optional tags ['cpucount' =&gt; 10], // optional additional fields 1435255849 // Time precision has to be set to seconds! ), new Point( 'test', // name of the measurement 0.84, // the measurement value ['host' =&gt; 'server01', 'region' =&gt; 'us-west'], // optional tags ['cpucount' =&gt; 10], // optional additional fields 1435255849 // Time precision has to be set to seconds! ));$result = $database-&gt;writePoints($points, Database::PRECISION_SECONDS); 3、封装成类使用代码传送门]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>InfluxDB</tag>
        <tag>Yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Window环境下安装并使用InfluxDB]]></title>
    <url>%2F20190523%2FWindow%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%AE%89%E8%A3%85%E5%B9%B6%E4%BD%BF%E7%94%A8InfluxDB.html</url>
    <content type="text"><![CDATA[1、简单介绍InfluxDB 是一个时间序列数据库，用于处理海量写入与负载查询。InfluxDB旨在用作涉及大量时间戳数据的任何用例（包括DevOps监控，应用程序指标，物联网传感器数据和实时分析）的后端存储。 三大特性 时序性（Time Series）：与时间相关的函数的灵活使用（诸如最大、最小、求和等）； 度量（Metrics）：对实时大量数据进行计算； 事件（Event）：支持任意的事件数据，换句话说，任意事件的数据我们都可以做操作。 2、下载与安装由于实际项目运行在window环境下，只做window的安装介绍 InfluxDB默认使用的两个http端口：8083，808612port 8083：管理页面端口，访问localhost:8083可以进入你本机的influxdb管理页面；port 8086：http连接influxdb client端口，一般使用该端口往本机的influxdb读写数据。 下载 直接从官网下载或者使用如下地址下载 1https://dl.influxdata.com/influxdb/releases/influxdb-1.7.6_windows_amd64.zip 下载解压后 在当前的influxdb文件下打开cmder，输入如下命令生成配置文件 1influxd.exe config &gt; auto.conf 打开auto.conf，调整 [meta] dir [data] dir wal-dir 默认路径有可能存在权限问题无法读写 123456789[meta] dir = "D:\\Influxdb17\\.influxdb\\meta" retention-autocreate = true logging-enabled = true[data] dir = "D:\\Influxdb17\\.influxdb\\data" index-version = "inmem" wal-dir = "D:\\Influxdb17\\.influxdb\\wal" 使用配置文件运行 1influxd.exe -config .\auto.conf 结果显示如下 3、链接与操作在当前的文件夹下新打开一个cmder窗口，直接输入如下命令运行 1influx influxdb基本操作整理如下 操作 SQL 显示用户 show users 创建用户 create user “username” with password “password” 创建管理员权限用户 create user “username” with password ‘password’ with all privileges 删除用户 drop user “username” 添加权限 GRANT ALL PRIVILEGES TO username 查看权限 SHOW GRANTS FOR admin 修改用户(密码) SET PASSWORD FOR username = ‘password’ 撤消权限 REVOKE ALL ON mydb FROM admin 显示所有数据库 show databases 使用数据库 use testdb 显示所有表 show measurements 查询表 select * from csm_status 创建表， 直接在插入数据的时候指定表名 insert test,host=127.0.0.1,monitor_name=test count=1 其中： 1、table：test 2、tag: host=127.0.0.1,monitor_name=test 3、field：count=1 注意tag与field直接不需要逗号 创建数据库 create database “db_name” 整理状态返回码以及说明 状态码 说明 204 No Content Success! 400 Bad Request Unacceptable request. Can occur with a Line Protocol syntax error or if a user attempts to write values to a field that previously accepted a different value type. The returned JSON offers further information. 401 Unauthorized Unacceptable request. Can occur with invalid authentication credentials. 404 Not Found Unacceptable request. Can occur if a user attempts to write to a database that does not exist. The returned JSON offers further information. 500 Internal Server Error The system is overloaded or significantly impaired. Can occur if a user attempts to write to a retention policy that does not exist. The returned JSON offers further information. HTTP API示例查询 1234#查询表的内容http://localhost:8086/query?db=testDb&amp;u=func&amp;p=passwd&amp;q=select%20*%20from%20csm_mach_spindle_detail#显示所有数据库http://localhost:8086/query?u=admin&amp;p=admin&amp;q=SHOW%20DATABASES 添加 1curl -i -XPOST 'http://127.0.0.1:8086/write?db=testDb' --data-binary 'test,host=127.0.0.1,monitor_name=test count=1']]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
      <tags>
        <tag>InfluxDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux环境下Apahce的调优]]></title>
    <url>%2F20190521%2FLinux%E7%8E%AF%E5%A2%83%E4%B8%8BApahce%E7%9A%84%E8%B0%83%E4%BC%98.html</url>
    <content type="text"><![CDATA[1、Apache禁止遍历目录将Options Indexes FollowSymLinks中的Indexes 去掉，就可以禁止Apache 显示该目录结构。Indexes 的作用就是当该目录下没有index.html文件时，就显示目录结构。 2、隐藏版本信息测试默认apache 的状态信息 12345678[root@izwz9f3z1ua4xcakn1y8t4z ~]# curl -Is localhostHTTP/1.1 302 FoundDate: Wed, 08 May 2019 08:27:23 GMTServer: Apache/2.4.6 (CentOS) PHP/7.1.12 OpenSSL/1.0.2k-fips mod_apreq2-20090110/2.8.0 mod_perl/2.0.10 Perl/v5.16.3Location: https://localhost/Cache-Control: max-age=86400Expires: Thu, 09 May 2019 08:27:23 GMTContent-Type: text/html; charset=iso-8859-1 修改主配置文件httpd.conf，将下面两行添加到配置文件的末尾 12ServerSignature OffServerTokens ProductOnly 重启Apahce 测试隐藏版本号后apache 的状态信息 12345678[root@izwz9f3z1ua4xcakn1y8t4z ~]# curl -Is localhostHTTP/1.1 302 FoundDate: Wed, 08 May 2019 08:29:09 GMTServer: ApacheLocation: https://localhost/Cache-Control: max-age=86400Expires: Thu, 09 May 2019 08:29:09 GMTContent-Type: text/html; charset=iso-8859-1 3、关闭trace-method配置文件添加一行 1TraceEnable off 4、Apache并发数调整12345678查看Apache的工作模式：apache -l如果出现prefork.c，则是工作在prefork模式下查看当前的连接数：ps aux|grep httpd|wc -lpgrep httpd|wc -l计算httpd占用内存的平均数：ps aux|grep -v grep|awk '/httpd/&#123;sum+=$6;n++&#125;;END&#123;print sum/n&#125;'使用ulimit -n 65535 增加文件打开数量 123# prefork MPM# StartServers:启动时服务器的进程数# MinSpareServers:保有的备用进程的最小数目 123456789101112131415161718192021222324252627282930313233343536373839404142# MaxSpareServers:保有的备用进程的最大数目# MaxClients:服务器允许启动的最大进程数# MaxRequestsPerChild:一个服务进程允许的最大请求数&lt;IfModule prefork.c&gt; // 设置使用预生派(Prefork MPM)运行方式的参数，此方式是Redhat默认的方式StartServers 8 // 设置服务器启动时运行的进程数为8MinSpareServers 5 // 如果低于5个空闲子进程，就会创建新的子进程为客户提供服务MaxSpareServers 20 // 如果存在高于20个空闲子进程,就创建逐一删除的子进程来提高系统性能MaxClients 150 // 限制同一时间连接数不能超过150MaxRequestPerChild 1000 // 限制每个子进程在结束请求之前能处理的连接请求为1000&lt;/IfModule&gt;# worker MPM# StartServers:启动时的服务进程数目# MaxClients:允许同时连接的最大用户数目# MinSpareThreads:保有的最小工作线程数目# MaxSpareThreads:允许保有的最大工作线程数目# ThreadsPerChild:每个服务进程中的工作线程常数# MaxRequestsPerChild:服务进程中允许的最大请求数目IfModule worker.c&gt; // 设置使用工作者模式(worker MPM)运行方式的参数StartServers 2MaxClients 150MinSpareThreads 25MaxSpareThreads 75ThreadsPerChild 25MaxRequestsPerChild 0&lt;/IfModule&gt;# perchild MPM# NumServers:服务进程数量# StartThreads:每个服务进程中的起始线程数量# MinSpareThreads:保有的最小线程数量# MaxSpareThreads:保有的最大线程数量# MaxThreadsPerChild:每个服务进程允许的最大线程数# MaxRequestsPerChild:每个服务进程允许连接的最大数量&lt;IfModule perchild.c&gt; // 设置使用独立子进程(Perchild MPM)运行方式的参数NumServers 5StartThreads 5MinSpareThreads 5MaxSpareThreads 10MaxThreadsPerChild 20MaxRequestsPerChild 0&lt;/IfModule&gt;]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python语言对MongoDB的相关操作]]></title>
    <url>%2F20190414%2FPython%E8%AF%AD%E8%A8%80%E5%AF%B9MongoDB%E7%9A%84%E7%9B%B8%E5%85%B3%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[MongoDB是由C++语言编写的非关系型数据库，是一个基于分布式文件存储的开源数据库系统，其内容存储形式类似于JSON对象，它的字段值可以包含其他文档，数组以及文档数组，非常灵活。 1、准备工作确保电脑安装了MongoDB并启动了其服务，并且安装了PyMongo库，本文不做介绍。 2、连接MongoDB连接MongoDB是，需要哦使用PyMongo库中的MongoClient。 1234import pymongo#client = pymongo.MongoClient(host='127.0.0.1', port=27017)client = pymongo.MongoClient('mongodb://127.0.0.1:27017/')#两种写法都可以达到相同的连接效果 3、指定数据库MongoDB中可以建立多个数据库，需要指定操作的数据库。 123db = client.test#db = client['test]#两种方法等价 4、指定集合MongoDB的每个数据库又包含许多集合（collection），类似于关系型数据库中的表。与指定数据库类似。 12collection = db.students#collection = db['students'] 这样我们便声明了一个Collection对象 5、插入数据新建一条学生数据，以字典形式表示： 123456student = &#123; 'id':'20170104', 'name':'Tomr', 'age':20, 'gender':'male'&#125; 这里指定了学生的学号、姓名、年龄和性别。直接调用collection的insert()方法即可插入数据 12res = collection.insert(student)print(res) 在MongoDB中，每条数据都有一个_id属性来唯一标识。如果没有显式指明该属性，MongoDB会自动产生一个ObjectId类型的 _id属性。insert()方法会执行后返回 _id值 运行结果如下 15cb1ea2230f1f4dfdcfa9234 还可同时插入多条数据，只需要以列表形式传递即可。 12345678910111213141516student = &#123; 'id':'20170104', 'name':'Tomr', 'age':20, 'gender':'male'&#125;student1 = &#123; 'id':'20170102', 'name':'Mike', 'age':25, 'gender':'male'&#125;res = collection.insert([student,student1])print(res)#返回结果是对应的 _id集合[ObjectId('5cb1eab130f1f4dc848730da'), ObjectId('5cb1eab130f1f4dc848730db')] 官方推荐使用insert_one()和insert_many()方法分别插入单条记录和多条记录。 123456789101112student = &#123; 'id':'20170104', 'name':'Tomr', 'age':20, 'gender':'male'&#125;res = collection.insert_one(student)print(res)print(res.inserted_id)#运行结果&lt;pymongo.results.InsertOneResult object at 0x0000019DF8C92C88&gt;5cb1eb5e30f1f4e04005dbfd 与insert()方法不同，返回的是InsertOneResult对象，调用其inserted_id属性获取 _id 对于insert_many()方法，将数据以列表形式传递。 12345678910111213141516171819student = &#123; 'id':'20170104', 'name':'Tomr', 'age':20, 'gender':'male'&#125;student1 = &#123; 'id':'20170102', 'name':'Mike', 'age':25, 'gender':'male'&#125;res = collection.insert_many([student,student1])print(res)print(res.inserted_ids)#运行结果&lt;pymongo.results.InsertManyResult object at 0x000001A658EC95C8&gt;[ObjectId('5cb1ec1b30f1f4c0fcb7a87b'), ObjectId('5cb1ec1b30f1f4c0fcb7a87c')] 返回的类型是InsertManyResult对象，调用inserted_ids属性可以获取插入数的 _id列表 6、查询查询使用find_one()或find()方法进行查询，其中find_one()查询得到的是单个结果，find()则返回一个生成器对象。 123res = collection.find_one(&#123;'name':'Mike'&#125;)print(type(res))print(res) 返回结果是字典类型，运行结果如下 12&lt;class 'dict'&gt;&#123;'_id': ObjectId('5cb1a00330f1f4aac47fad27'), 'id': '20170102', 'name': 'Mike', 'age': 25, 'gender': 'male'&#125; 也可以根据ObjectId来查询，此时需要使用bson库里面的objectid 1234567from bson.objectid import ObjectIdres = collection.find_one(&#123;'_id':ObjectId('5cb1a00330f1f4aac47fad27')&#125;)print(type(res))print(res)#运行结果&lt;class 'dict'&gt;&#123;'_id': ObjectId('5cb1a00330f1f4aac47fad27'), 'id': '20170102', 'name': 'Mike', 'age': 25, 'gender': 'male'&#125; 如果查询结果不存在，则返回None 查询多条数据使用find() 1234567891011res = collection.find(&#123;'age':20&#125;)print(type(res))print(res)for item in res: print(item)#运行结果&lt;class 'pymongo.cursor.Cursor'&gt;&lt;pymongo.cursor.Cursor object at 0x000001C8D596FD68&gt;&#123;'_id': ObjectId('5cb19fa930f1f4aa3c2439d5'), 'id': '20170101', 'name': 'Tom', 'age': 20, 'gender': 'male'&#125;&#123;'_id': ObjectId('5cb1a00330f1f4aac47fad26'), 'id': '20170104', 'name': 'Tomr', 'age': 20, 'gender': 'male'&#125;&#123;'_id': ObjectId('5cb1a03a30f1f4a55459e359'), 'id': '20170104', 'name': 'Tomr', 'age': 20, 'gender': 'male'&#125; 返回结果是Cursor类型，相当于一个生成器。 查询年龄大于20的数据 1res = collection.find(&#123;'age':&#123;'$gt':20&#125;&#125;) 比较符号归纳如下 符号 含义 示例 $lt 小于 {‘age’:{‘$lt’:20}} $gt 大于 {‘age’:{‘$gt’:20}} $lte 小于等于 {‘age’:{‘$lte’:20}} $gte 大于等于 {‘age’:{‘$gte’:20}} $ne 不等于 {‘age’:{‘$ne’:20}} $in 在范围内 {‘age’:{‘$in’:[20,30]}} $nin 不在范围内 {‘age’:{‘$nin’:[20,30]}} 还可以进行正则匹配查询，例如查询名字以M开头的学生数据，示例如下： 123res = collection.find(&#123;'name':&#123;'$regex':'^M.*'&#125;&#125;)for item in res: print(item) 符号 含义 示例 示例含义 $regex 匹配正则表达式 {‘name’:{‘$regex’:’^M.*’}} name以M开头 $exists 属性是否存在 {‘name’:{‘$exists’:True}} name属性存在 $type 类型判断 {‘age’:{‘$type’:’int’}} age的类型为int $mod 数字模操作 {‘age’:{‘$mod’:[5,0]}} 年龄模5余0 $text 文本查询 {‘$text’:{‘$search’:’Mike’}} text类型的属性中包含Mike字符串 $where 高级条件查询 {‘$where’:’obj.fans_count==obj.follows_count’} 自身粉丝数等于关注数 7、计数统计查询结果，可以调用count()方法 1234res = collection.find().count()print(res)#运行结果12 统计符合条件的数据总数 1234res = collection.find(&#123;'name':&#123;'$regex':'^M.*'&#125;&#125;).count()print(res)#运行结果4 8、排序直接调用sort()方法，并在其中传入排序的字段以及升降序标志即可 1234res = collection.find().sort('name', pymongo.ASCENDING)print([item['name'] for item in res])#运行结果['Mike', 'Mike', 'Mike', 'Mike', 'Tom', 'Tomr', 'Tomr', 'Tomr', 'Tomr', 'Tomr', 'Tomr', 'Tomr'] 其中pymongo.ASCENDING指定升序，pymongo.DESCENDING指定降序 9、偏移只是查询几个元素，可以使用skip()方法便宜几个位置，比如偏移3，就忽略前三个元素，得到第四个以后的元素 1234res = collection.find().sort('name', pymongo.ASCENDING).skip(3)print([item['name'] for item in res])#运行结果['Mike', 'Tom', 'Tomr', 'Tomr', 'Tomr', 'Tomr', 'Tomr', 'Tomr', 'Tomr'] 还可以使用limit()方法指定要取结果个数， 1234res = collection.find().sort('name', pymongo.ASCENDING).skip(3).limit(2)print([item['name'] for item in res])#运行结果['Mike', 'Tom'] 注意的是，在数据库数量非常庞大的时候，如千万，亿级别，最好不要使用大的派年以来来查询数据，可能会导致内存溢出，可以类似如下操作查询。 12from bson.objectid import ObjectIdres = collection.find_one(&#123;'_id':&#123;'$gt': ObjectId('5cb1a00330f1f4aac47fad27')&#125;&#125;) 这时需要记录上次查询的 _id。 10、更新数据更新可以使用update()方法，指定更新的条件和更新后的数据即可。 1234567891011121314151617condition = &#123;'name':'Tom'&#125;st = collection.find_one(condition)print('更新前')print(st)st['age'] = 20res = collection.update(condition, st)print(res)print('更新后')st = collection.find_one(condition)print(st)#运行结果更新前&#123;'_id': ObjectId('5cb19fa930f1f4aa3c2439d5'), 'id': '20170101', 'name': 'Tom', 'age': 25, 'gender': 'male'&#125;res = collection.update(condition, st)&#123;'n': 1, 'nModified': 1, 'ok': 1.0, 'updatedExisting': True&#125;更新后&#123;'_id': ObjectId('5cb19fa930f1f4aa3c2439d5'), 'id': '20170101', 'name': 'Tom', 'age': 20, 'gender': 'male'&#125; 更新结果返回字典形式，ok代表执行成功，nModified代表影响的数据条数。 也可以使用$set操作符对数据进行更新 1res = collection.update(condition, &#123;'$set',st&#125;) 这样可以只更新st字典中存在的字段，如果原先还有其他字段，则不hi更新，也不会删除。而不用$set，则会把之前的数据全部用st字典替换，原本存在其他字段，则会被删除。 官方推荐使用update_on()和update_many()方法，用法更加严格。它们的第二个参数需要使用$类型操作符作为字典的键名。 123456789st['age'] = 30#res = collection.update(condition, st)#res = collection.update(condition, &#123;'$set',st&#125;)res = collection.update_one(condition, &#123;'$set':st&#125;)print(res)print(res.matched_count, res.modified_count)#结果&lt;pymongo.results.UpdateResult object at 0x00000188BDA89B88&gt;1 1 第二个参数不能直接传入修改后的字典，俄日是需要使用{‘$set’:st}这样的形式，返回结构是UpdateResult类型，分别调用matched_count和modified_count属性，可以获得匹配的数据条数和影响的数据条数。 1234567condition = &#123;'age':&#123;'$gt':20&#125;&#125;res = collection.update_one(condition, &#123;'$inc':&#123;'age':1&#125;&#125;)print(res)print(res.matched_count, res.modified_count)#结果&lt;pymongo.results.UpdateResult object at 0x00000243ACB70308&gt;1 1 指定查询条件为年龄大于20，更新条件为{‘$inc’:{‘age’:1}，也就是年龄加1,执行之后将第一条符合条件的数据年龄加1。 调用update_many()方法，则将所有符合条件的数据都更新 1234567condition = &#123;'age':&#123;'$gt':20&#125;&#125;res = collection.update_many(condition, &#123;'$inc':&#123;'age':1&#125;&#125;)print(res)print(res.matched_count, res.modified_count)#运行结果&lt;pymongo.results.UpdateResult object at 0x00000206A9C89608&gt;5 5 11、删除删除操作比较简单。直接使用remove()方法指定删除的条件即可，符合条件的所有数均会被删除。 1234res = collection.remove(&#123;'name':'Tom'&#125;)print(res)#运行结果&#123;'n': 1, 'ok': 1.0&#125; 还可使用推荐方法delete_one()和delete_many(). 12345678910res = collection.delete_one(&#123;'name':'Mike'&#125;)print(res)print(res.deleted_count)res = collection.delete_many(&#123;'age':&#123;'$lt':30&#125;&#125;)print(res)print(res.deleted_count)运行结果&lt;pymongo.results.DeleteResult object at 0x0000019068652848&gt;15 delete_one()删除第一条符合条件的数据，delete_many()删除所有符合条件的数据，返回结果都是DeleteResult类型，可以调用delete_count()属性获取删除的数据条数. 12、其他操作PyMongo还提供了一些组合方法，如find_one_and_delete()，find_one_and_replace()和find_one_and_update()表示查找后删除，替换，更新操作，用法一致。 还可以对索进行操作，有create_index(),create_indexes()和drop_index()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>数据库</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7安装后修改yum和epel源]]></title>
    <url>%2F20190326%2FCentos7%E5%AE%89%E8%A3%85%E5%90%8E%E4%BF%AE%E6%94%B9yum%E5%92%8Cepel%E6%BA%90.html</url>
    <content type="text"><![CDATA[centos7安装后一系列的修改配置国内yum源和epel源 1、新建repo_bak目录，将原来的repo文件移到新建目录中123cd /etc/yum.repos.d/mkdir repo_bakmv *.repo repo_bak/ 2、配置使用网易和阿里的开源镜像12345wget http://mirrors.aliyun.com/repo/Centos-7.repowget http://mirrors.163.com/.help/CentOS7-Base-163.repols#结果显示Centos-7.repo CentOS-Base-163.repo repo.bak 3、清除yum缓存重新生成新的yum缓存12345678910yum clean all #清除所有的缓存#结果显示Loaded plugins: fastestmirrorRepository base is listed more than once in the configurationRepository updates is listed more than once in the configurationRepository extras is listed more than once in the configurationRepository centosplus is listed more than once in the configurationCleaning repos: base extras updatesCleaning up list of fastest mirrorsyum makecache #生成yum缓存 结果显示 4、安装epel源12345678yum list | grep epel-releaseRepository base is listed more than once in the configurationRepository updates is listed more than once in the configurationRepository extras is listed more than once in the configurationRepository centosplus is listed more than once in the configurationepel-release.noarch 7-11 extras yum install -y epel-release#结果显示 5、配置阿里云epel源12# 下载阿里开源镜像的epel源文件wget -O /etc/yum.repos.d/epel-7.repo http://mirrors.aliyun.com/repo/epel-7.repo 结果显示 6、再次清楚yum缓存，并重新生成yum缓存 7、查看系统可用的yum源以及所有yum源 12yum repolist enabled #查询可用的源yum repolist all#查询所有的源 至此 配置yum和epel源结束 9 每天自动更新配置手动更新所有预先安装得软件 1yum -y update 设定系统定时自动更新，确定服务器是否安装了自动执行指令得工具 安装 cron和anacron 12yum -y install cronieyum -y install yum-cron 完成后系统多了数个档案，比较重要的包括： 1234/etc/cron.daily/0yum.cron#每天执行这个档案一次，它根据配置档案 /etc/yum/yum-cron.conf 来更新软件/etc/yum/yum-cron.conf#这是每天执行yum-cron的配置档案，默认只会下载更新的软件，并不安装，用意是让管理员检视yum-cron的输出，选取需要更新的软件进行手动安装。 10、修改配置 1vim /etc/yum/yum-cron.conf 寻找： 1234567apply_updates=no #修改为apply_updates=yes#确认一下参数一致update_messages=yesdownload_updates=yesapply_updates=yes 启动crond和yum-cron 12systemctl start crondsystemctl start yum-cron 7、防火墙安装防火墙 1yum install firewalld 查看防火墙启用的端口 1firewall-cmd --list-all]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Centos7</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[虚拟机安装Centos7后配置网络]]></title>
    <url>%2F20190326%2F%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%AE%89%E8%A3%85Centos7%E5%90%8E%E9%85%8D%E7%BD%AE%E7%BD%91%E7%BB%9C.html</url>
    <content type="text"><![CDATA[快速解决虚拟机中centos7链接网络的方法 1、 打开虚拟机的编辑菜单，选择”虚拟机网络编辑器“ 在虚拟机网络编辑器中选择还原默认设置 开启centos7虚拟机 必须用管理员的身份登录 登录成功后，开始配置网络 在终端输入 1ls /etc/sysconfig/network-scripts 显示结果如下 在终端 用vi打开 ifcfg-ensXXX 1vi ifcfg-ems33 结果如下 在编辑模式下修改 12BOOTPROTO=dhcpONBOOT=yes 保存退出 在物理机中设置虚拟机的VMware DHCP Service和VMware NAT Service服务，确保两个服务处于开启状态， 新建一个bat文件，文件内容如下 123net start "VMware DHCP Service"net start "VMware NAT Service"pause 执行这个bat文件后，重启虚拟机的network服务 在终端输入 1service network restart 结果返回 最后ping百度结果显示 1ping www.baidu.com 结果显示 出现如上结果说明，配置虚拟机网络成功 设置静态ip 进入网络ip地址配置文件夹 1cd /etc/sysconfig/network-scripts/ 查看当前网卡的名称 1ifconfig 如果出现如下错误 1-bash: ifconfig: 未找到命令 是因为没有安装net-tools 直接运行 1yum -y install net-tools 安装成功后，再运行ifconfig查看当前网卡名称 123456789101112131415161718[root@localhost network-scripts]# ifconfigens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt; mtu 1500 inet 10.10.10.230 netmask 255.255.255.0 broadcast 10.10.10.255 inet6 fe80::aabc:70b8:a270:fec0 prefixlen 64 scopeid 0x20&lt;link&gt; ether 00:0c:29:6f:07:5f txqueuelen 1000 (Ethernet) RX packets 161110 bytes 75000638 (71.5 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 20484 bytes 1617802 (1.5 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt; mtu 65536 inet 127.0.0.1 netmask 255.0.0.0 inet6 ::1 prefixlen 128 scopeid 0x10&lt;host&gt; loop txqueuelen 1000 (Local Loopback) RX packets 32481 bytes 2281004 (2.1 MiB) RX errors 0 dropped 0 overruns 0 frame 0 TX packets 32481 bytes 2281004 (2.1 MiB) TX errors 0 dropped 0 overruns 0 carrier 0 collisions 0 即ens33，其网卡对应的配置文件为ifcfg-ens33 编辑该文件 1234567891011121314151617181920iTYPE=EthernetPROXY_METHOD=noneBROWSER_ONLY=noBOOTPROTO=static # 使用静态IP地址，默认为dhcpIPADDR="10.10.10.230" # 设置的静态IP地址 NETMASK="255.255.255.0" # 子网掩码 GATEWAY="10.10.10.1" # 网关地址 DNS1="192.168.241.2" # DNS服务器DNS2="192.168.241.3"DEFROUTE=yesIPV4_FAILURE_FATAL=noIPV6INIT=yesIPV6_AUTOCONF=yesIPV6_DEFROUTE=yesIPV6_FAILURE_FATAL=noIPV6_ADDR_GEN_MODE=stable-privacyNAME=ens33UUID=3233181c-fd9a-4809-b008-a6d9840b09c3DEVICE=ens33ONBOOT=yes 保存，重启网络服务 1service network restart 重新输入ip addr 进行查看，更改成功，如果没有成功，重启（reboot） 网络测试 使用ping命令，能ping通网关和外网，则表示网络正常 1234567891011121314151617[root@localhost ~]# ping 10.10.10.1PING 10.10.10.1 (10.10.10.1) 56(84) bytes of data.64 bytes from 10.10.10.1: icmp_seq=1 ttl=64 time=1.54 ms64 bytes from 10.10.10.1: icmp_seq=2 ttl=64 time=1.54 ms64 bytes from 10.10.10.1: icmp_seq=3 ttl=64 time=2.13 ms64 bytes from 10.10.10.1: icmp_seq=4 ttl=64 time=1.38 ms64 bytes from 10.10.10.1: icmp_seq=5 ttl=64 time=1.69 ms64 bytes from 10.10.10.1: icmp_seq=6 ttl=64 time=1.84 ms64 bytes from 10.10.10.1: icmp_seq=7 ttl=64 time=1.75 ms[root@localhost ~]# ping www.baidu.comPING www.a.shifen.com (14.215.177.39) 56(84) bytes of data.64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=1 ttl=56 time=8.47 ms64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=2 ttl=56 time=9.30 ms64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=3 ttl=56 time=9.38 ms64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=4 ttl=56 time=7.66 ms64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=5 ttl=56 time=8.44 ms64 bytes from 14.215.177.39 (14.215.177.39): icmp_seq=6 ttl=56 time=10.1 ms]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Centos7</tag>
        <tag>Linux</tag>
        <tag>虚拟机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[了解域名SSL证书申请安装]]></title>
    <url>%2F20190322%2F%E4%BA%86%E8%A7%A3%E5%9F%9F%E5%90%8DSSL%E8%AF%81%E4%B9%A6%E7%94%B3%E8%AF%B7%E5%AE%89%E8%A3%85.html</url>
    <content type="text"><![CDATA[了解域名SSL证书申请安装 如何将自己的网站的访问协议http转成https协议，就得要求我们必须对域名进行SSl证书申请并应用。 申请域名可以在阿里云，腾讯云等平台购买，在此文章不做详细的介绍（因为主角不是它） 证书购买在阿里云官网搜索SSL相关产品 选择免费证书类型 免费的不用花钱一直确认就行， 最后在 SSL证书控制台看到 如下图 未签发的证书。 购买完成后，就给已申请的域名申请SSL证书。 点击 申请 按钮 写证书申请相关信息 提交验证，等待审核成功，证书通过审核如图 网站实现http转https需要下载对应应用的证书及密钥，如图 下载后包含的文件有如图所示 文件介绍 在证书控制台下载Apache版本证书，下载到本地的是一个压缩文件，解压后里面包含_public.crt文件是证书文件，_chain.crt是证书链(中间证书)文件，.key文件是证书的私钥文件（申请证书时如果没有选择系统创建CSR，则没有该文件）。 友情提示： .crt扩展名的证书文件采用Base64-encoded的PEM格式文本文件，可根据需要，修改成.pem等扩展名。 以Apache标准配置为例，假如证书文件名是a_public.crt，证书链文件是a_chain.crt,私钥文件是a.key。 Apache服务器安装SSL证书1、将下载的全部文件拷贝到Apahce的安装目录下1/etc/httpd/cert 2、修改apache配置1vim /etc/httpd/conf/httpd.conf 找到如下内容去掉 # 号 12#LoadModule ssl_module modules/mod_ssl.so (如果找不到请确认是否编译过 openssl 插件)#Include conf/extra/httpd-ssl.conf（删除行首的配置语句注释符号“#”，保存后退出） 注意 用yum安装的apache是没有启用ssl的，所有我们需要安装mod_ssl模块提供TLS/SSL功能 3、检查并安装mod_ssl123ls /etc/httpd/modules/ | grep "mod_ssl" #默认没有安装mod_sslyum list all mod_ssl #查看mod_ssl的安装包信息yum install -y mod_ssl #安装mod_ssl 4、检查安装mod_ssl安装结果1234rpm -qc mod_ssl#结果显示/etc/httpd/conf.d/ssl.conf #mod_ssl的配置文件存放位置/etc/httpd/conf.modules.d/00-ssl.conf 5、修改ssl.conf1vim /etc/httpd/conf.d/ssl.conf 配置文件中如下内容修改 1234567891011# 添加 SSL 协议支持协议，去掉不安全的协议SSLProtocol all -SSLv2 -SSLv3# 修改加密套件如下SSLCipherSuite HIGH:!RC4:!MD5:!aNULL:!eNULL:!NULL:!DH:!EDH:!EXP:+MEDIUMSSLHonorCipherOrder on# 证书公钥配置SSLCertificateFile cert/a_public.crt# 证书私钥配置SSLCertificateKeyFile cert/a.key# 证书链配置，如果该属性开头有 '#'字符，请删除掉SSLCertificateChainFile cert/a_chain.crt 6、重启apache1systemctl restart httpd 结果提示如下 12Redirecting to /bin/systemctl restart httpd.service Job for httpd.service failed. See ‘systemctl status httpd.service’ and ‘journalctl -xn’ for details. 使用如下代码检测httpd配置文件 1234httpd -t#结果[Thu Mar 21 22:46:40.320592 2019] [so:warn] [pid 2255] AH01574: module php7_module is already loaded, skippingSyntax OK 格式没有错 查看ssl日志 123456cat /etc/httpd/logs/ssl_error_log#结果如下[Thu Mar 21 21:49:26.894751 2019] [ssl:warn] [pid 1344] AH01909: RSA certificate configured for localhost:443 does NOT include an ID which matches the server name[Thu Mar 21 21:49:26.943935 2019] [ssl:warn] [pid 1344] AH01909: RSA certificate configured for localhost:443 does NOT include an ID which matches the server name[Thu Mar 21 21:53:36.304483 2019] [ssl:warn] [pid 1433] AH01909: RSA certificate configured for localhost:443 does NOT include an ID which matches the server name[Thu Mar 21 21:53:36.337643 2019] [ssl:warn] [pid 1433] AH01909: RSA certificate configured for localhost:443 does NOT include an ID which matches the server name 端口443未设置， 修改 httpd.conf 1ServerName localhost 改为 ServerName localhost:443 重启apahce正常 在网站根目录下创建.htaccess文件，在最下面添加写入如下语句： 1234RewriteEngine onRewriteBase / RewriteCond %&#123;SERVER_PORT&#125; !^443$RewriteRule ^.*$ https://%&#123;SERVER_NAME&#125;%&#123;REQUEST_URI&#125; [L,R]]]></content>
      <categories>
        <category>技术杂谈</category>
      </categories>
      <tags>
        <tag>服务器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础整理元组基本操作]]></title>
    <url>%2F20190314%2FPython%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%E5%85%83%E7%BB%84%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[元组 1、基本语法以及格式Python 的元组与列表类似，不同之处在于元组的元素不能修改。元组使用小括号，列表使用方括号。 元组创建很简单，只需要在括号中添加元素，并使用逗号隔开即可。 实例1234#!/usr/bin/env python# -*- coding: utf-8 -*-aTuple = (200, 50, 10, 33, 44,45)print(aTuple) 结果1(200, 50, 10, 33, 44, 45) 2、访问元组使用下标索引来访问元组中的值 实例 123456#!/usr/bin/env python# -*- coding: utf-8 -*-aTuple = (200, 50, 10, 33, 44,45)print(aTuple)print(aTuple[0])print(aTuple[1]) 结果 123(200, 50, 10, 33, 44, 45)20050 3、修改元组实例 123456#!/usr/bin/env python# -*- coding: utf-8 -*-aTuple = (200, 50, 10, 33, 44,45)print(aTuple)aTuple[0] = 400print(aTuple[0]) 结果 12345(200, 50, 10, 33, 44, 45)Traceback (most recent call last): File "i:/Python学习/demo/元组.py", line 5, in &lt;module&gt; aTuple[0] = 400TypeError: 'tuple' object does not support item assignment 程序运行出现异常，说明 不允许修改元组的数据。 但是我们可以对元组进行连接组合 实例 1234567#!/usr/bin/env python# -*- coding: utf-8 -*-aTuple = (200, 50, 10, 33, 44,45)bTuple = (300, 400, 500)print(aTuple)print(aTuple[0])print(aTuple[1]) 创建新元组12cTuple = aTuple + bTupleprint(cTuple) 结果 1234(200, 50, 10, 33, 44, 45)20050(200, 50, 10, 33, 44, 45, 300, 400, 500) 4、删除元组元组中的元素值是不允许删除的，但我们可以使用del语句来删除整个元组。 实例 123456789#!/usr/bin/env python# -*- coding: utf-8 -*-aTuple = (200, 50, 10, 33, 44,45)bTuple = (300, 400, 500)print(aTuple)print(aTuple[0])print(aTuple[1])del aTupleprint(aTuple) 结果 1234567(200, 50, 10, 33, 44, 45)20050Traceback (most recent call last): File "i:/Python学习/demo/元组.py", line 9, in &lt;module&gt; print(aTuple)NameError: name 'aTuple' is not defined 元组aTuple被删除后，输出百年来会程序出现异常。 5、内置函数len 计算元组元素的个数 实例 12345#!/usr/bin/env python# -*- coding: utf-8 -*-aTuple = (200, 50, 10, 33, 44,45)print(len(aTuple)) 结果 16 max 返回元组的最大值 实例 12345#!/usr/bin/env python# -*- coding: utf-8 -*-aTuple = (200, 50, 10, 33, 44,45)print(max(aTuple)) 结果 1200 min 返回元组的最小值 实例 12345#!/usr/bin/env python# -*- coding: utf-8 -*-aTuple = (200, 50, 10, 33, 44,45)print(min(aTuple)) 结果 110 tuple 将列表转换为元组 实例 123456#!/usr/bin/env python# -*- coding: utf-8 -*-list1= ['Google', 'Taobao', 'Runoob', 'Baidu']print(type(list1))tup = tuple(list1)print(type(tup)) 结果 12&lt;class 'list'&gt;&lt;class 'tuple'&gt; index和count与字符串和列表中的用法相同 实例 1234567#!/usr/bin/env python# -*- coding: utf-8 -*-a = ('a', 'b', 'c', 'a', 'b')b = a.index('b', 1, 4) # 注意是左闭右开区间print(b)print(a.count('b'))print(a.count('d')) 结果 123120]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟登陆豆瓣并爬去豆瓣主页的部分数据]]></title>
    <url>%2F20190226%2F%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86%E8%B1%86%E7%93%A3%E5%B9%B6%E7%88%AC%E5%8E%BB%E8%B1%86%E7%93%A3%E4%B8%BB%E9%A1%B5%E7%9A%84%E9%83%A8%E5%88%86%E6%95%B0%E6%8D%AE.html</url>
    <content type="text"><![CDATA[该文章主要使用selenium模拟登陆豆瓣，并且提取主页的部分信息。 selenium的安装以及基本使用在前面的文章有介绍。 功能要求： 1、模拟登陆豆瓣 2、爬去主页的部分信息并打印出来 程序代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253#!/usr/bin/env python# -*- encoding: utf-8 -*-'''@File : 模拟登陆豆瓣.py@Time : 2019/02/23 16:20:11@Author : My.Yong @Version : 1.0@Contact : raogx.vip@hotmail.com@License : (C)Copyright 2017-2018, Liugroup-NLPR-CASIA@Desc : None'''# here put the import libfrom selenium import webdriverfrom selenium.webdriver.common.keys import Keysfrom selenium.webdriver import ActionChainsimport time,requestsfrom bs4 import BeautifulSoupdriver = webdriver.PhantomJS(executable_path='D:/phantomjs/bin/phantomjs.exe')driver.get('https://accounts.douban.com/passport/login_popup?login_source=anony')#模拟点击切换 选择密码登陆tab = driver.find_element_by_xpath('//li[@class="account-tab-account"]')#在 tab 位置单击ActionChains(driver).move_to_element(tab).click(tab).perform()#输入账号密码driver.find_element_by_id('username').send_keys('xxxxxxx')driver.find_element_by_id('password').send_keys('xxxxxxxx')#模拟点击登陆driver.find_element_by_xpath('//div[@id="tmpl_phone"]/div[@class="account-form-field-submit "]/a').click()#等待3秒time.sleep(1)base_url = 'https://www.douban.com/'driver.get(base_url)html = driver.page_sourcesoup = BeautifulSoup(html, 'lxml')nodes = soup.select('.status-wrapper')for node in nodes: text = node.select('.content p') text = text[0].get_text() if len(text) &gt; 0 else 0 print(text)#for item in nodes:# print(item)#response = requests.get(another_url, headers=headers)#print(response.content)#生产登陆后快照driver.save_screenshot('douban.png')driver.quit()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整理一波PHP计算时间的方法]]></title>
    <url>%2F20190226%2F%E6%95%B4%E7%90%86%E4%B8%80%E6%B3%A2PHP%E8%AE%A1%E7%AE%97%E6%97%B6%E9%97%B4%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[项目开发工作中会用到计算今日、昨日、前7天、前30天等时间，或当前时间（某个时间）的一个月之前、一个月之后的日期等， 该文章整理一下常用的时间计算方法。 主要用到的php时间内置方法有123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354date();#计算具体的时间日期strtotime();mktime();#输出时间戳echo '今天日期：'.date('Y-m-d', time());echo '当前时间：'.date("Y-m-d H:i:s",strtotime("today")); echo "指定时间戳的日期：".date('Y-m-d', $timestamp);echo "指定时间戳的时间：".date('Y-m-d H:i:s', $timestamp);echo "昨天的日期：".date("Y-m-d",strtotime("-1 day"));#或echo "昨天的日期：".date("Y-m-d",strtotime("yesterday"));echo "明天的日期：".date("Y-m-d",strtotime("+1 day"));#或echo "明天的日期：".date("Y-m-d",strtotime("tomorrow "));echo "获取7天前日期".date("Y-m-d",strtotime("-7 day"));echo "获取7天后日期".date("Y-m-d",strtotime("+7 day"));echo "获取一周后日期".date("Y-m-d",strtotime("+1 week"));echo "获取一周前日期".date("Y-m-d",strtotime("-1 week"));echo "获取30天前日期".date("Y-m-d",strtotime("-30 day"));echo "获取30天后日期".date("Y-m-d",strtotime("+30 day"));echo "获取一个月前日期".date("Y-m-d",strtotime("-1 month"));#或echo "获取一个月前日期".date("Y-m-d",strtotime("last month"));echo "获取一个月后日期".date("Y-m-d",strtotime("+1 month"));echo "获取上个周一日期".date("Y-m-d",strtotime("last Monday"));echo "获取下个周一日期".date("Y-m-d",strtotime("next Monday"));echo "获取一周零两天四小时五分钟两秒后时间".date("Y-m-d H:i:s",strtotime("+1 week 2 days 4 hours 5 minute 2 seconds"));//php获取今天起止时间戳mktime(0, 0, 0, date('m'), date('d'), date('Y')); mktime(0, 0, 0, date('m'), date('d') + 1, date('Y')) - 1; //php获取昨天起止时间戳mktime(0, 0, 0, date('m'), date('d') - 1, date('Y'));mktime(0, 0, 0, date('m'), date('d'), date('Y')) - 1; //php获取上周起止时间戳mktime(0, 0, 0, date('m'), date('d') - date('w') + 1 - 7, date('Y'));mktime(23, 59, 59, date('m'), date('d') - date('w') + 7 - 7, date('Y'));//php获取本月起止时间戳mktime(0, 0, 0, date('m'), 1, date('Y')); mktime(23, 59, 59, date('m'), date('t'), date('Y')); 整理参考：爱国足de博客]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Selenium知识点整理之安装入门]]></title>
    <url>%2F20190225%2FSelenium%E7%9F%A5%E8%AF%86%E7%82%B9%E6%95%B4%E7%90%86%E4%B9%8B%E5%AE%89%E8%A3%85%E5%85%A5%E9%97%A8.html</url>
    <content type="text"><![CDATA[SeleniumSelenium是一个Web的自动化测试工具，最初是为网站自动化测试而开发的，类型像我们玩游戏用的按键精灵，可以按指定的命令自动操作， 不同是Selenium 可以直接运行在浏览器上，它支持所有主流的浏览器（包括PhantomJS这些无界面的浏览器）。 Selenium 自己不带浏览器，不支持浏览器的功能，它需要与第三方浏览器结合在一起才能使用。 但是我们有时候需要让它内嵌在代码中运行，所以我们可以用一个叫 PhantomJS 的工具代替真实的浏览器。 安装 1pip install selenium PhantomJSPhantomJS 是一个基于Webkit的“无界面”(headless)浏览器，它会把网站加载到内存并执行页面上的 JavaScript， 因为不会展示图形界面，所以运行起来比完整的浏览器要高效。 安装 根据地址下载，并且配置到系统变量中1http://phantomjs.org/download.html 入门直接上代码 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768# 导入 webdriverfrom selenium import webdriver# 要想调用键盘按键操作需要引入keys包from selenium.webdriver.common.keys import Keys# 调用环境变量指定的PhantomJS浏览器创建浏览器对象driver = webdriver.PhantomJS()# 如果没有在环境变量指定PhantomJS位置# driver = webdriver.PhantomJS(executable_path="./phantomjs"))# get方法会一直等到页面被完全加载，然后才会继续程序，通常测试会在这里选择 time.sleep(2)driver.get("http://www.baidu.com/")# 获取页面名为 wrapper的id标签的文本内容data = driver.find_element_by_id("wrapper").text# 打印数据内容print(data)# 打印页面标题 "百度一下，你就知道"print(driver.title)# 生成当前页面快照并保存driver.save_screenshot("baidu.png")# id="kw"是百度搜索输入框，输入字符串"长城"driver.find_element_by_id("kw").send_keys(u"长城")# id="su"是百度搜索按钮，click() 是模拟点击driver.find_element_by_id("su").click()# 获取新的页面快照driver.save_screenshot("长城.png")# 打印网页渲染后的源代码print driver.page_source# 获取当前页面Cookieprint driver.get_cookies()# ctrl+a 全选输入框内容driver.find_element_by_id("kw").send_keys(Keys.CONTROL,'a')# ctrl+x 剪切输入框内容driver.find_element_by_id("kw").send_keys(Keys.CONTROL,'x')# 输入框重新输入内容driver.find_element_by_id("kw").send_keys("itcast")# 模拟Enter回车键driver.find_element_by_id("su").send_keys(Keys.RETURN)# 清除输入框内容driver.find_element_by_id("kw").clear()# 生成新的页面快照driver.save_screenshot("itcast.png")# 获取当前urlprint(driver.current_url)# 关闭当前页面，如果只有一个页面，会关闭浏览器# driver.close()# 关闭浏览器driver.quit()]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[干货分享！！！Yii1封装Cookie操作]]></title>
    <url>%2F20190223%2F%E5%B9%B2%E8%B4%A7%E5%88%86%E4%BA%AB%EF%BC%81%EF%BC%81%EF%BC%81Yii1%E5%B0%81%E8%A3%85Cookie%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[项目中经常使用到Cookie，本文分享一下Yii1封装的Cookie类，方便程序中调用 直接上代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778// +----------------------------------------------------------------------// | Yii1.1 Cookie操作类// +----------------------------------------------------------------------// | Author: Mr.Yong &lt;m.yong@foxmail.com&gt;// +----------------------------------------------------------------------// | Create Date: 2019.02.23// +----------------------------------------------------------------------final class Cookie &#123; /** * [get 获取 Cookie] * @Author My * @DateTime 2019-02-23T15:58:17+0800 * @param [type] $name [名称] * @return [type] [description] */ static public function get($name) &#123; if (!(is_string($name) &amp;&amp; $name)) &#123; return false; &#125; $cookie = Yii::app()-&gt;getRequest()-&gt;getCookies()-&gt;itemAt($name); if (is_null($cookie)) &#123; return false; &#125; else &#123; return $cookie-&gt;value; &#125; &#125; /** * [set 设置 Cookie] * @Author My * @DateTime 2019-02-23T15:57:40+0800 * @param [type] $name [名称] * @param string $value [值] * @param integer $expire [时间，单位：秒] * @param array $options [选项，具体请参考 CHttpCookie] */ static public function set($name, $value = '', $expire = 0, $options = []) &#123; if (!is_string($name) || !is_int($expire) || !is_array($options)) &#123; return false; &#125; $cookie = new CHttpCookie($name, $value); if ($expire) &#123; $cookie-&gt;expire = time() + $expire; &#125; if (!empty($options)) &#123; foreach ($options as $optionIndex =&gt; $optionVal) &#123; $cookie-&gt;$optionIndex = $optionVal; &#125; &#125; Yii::app()-&gt;getRequest()-&gt;cookies[$name] = $cookie; return true; &#125; /** * [remove 删除指定Cookie] * @Author My * @DateTime 2019-02-23T15:58:46+0800 * @param [type] $name [名称] * @return [type] [description] */ static public function remove($name) &#123; if (!(is_string($name) &amp;&amp; $name) || !isset(Yii::app()-&gt;getRequest()-&gt;cookies[$name])) &#123; return false; &#125; self::set($name, '', -1); return true; &#125; /** * [clear 清除全部 Cookie] * @Author My * @DateTime 2019-02-23T15:58:34+0800 * @return [type] [description] */ static public function clear() &#123; Yii::app()-&gt;getRequest()-&gt;getCookies()-&gt;clear(); &#125;&#125; 类文件直接放在 1/protected/components 调用方法： 设置cookie 1Cookie::set('name', '老马', 60); 获取cookie 1Cookie::get('name'); 删除指定cookie 1Cookie::remove('name'); 清除所有cookie 1Cookie::clear();]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Yii</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python分析一波微信好友]]></title>
    <url>%2F20190218%2FPython%E5%88%86%E6%9E%90%E4%B8%80%E6%B3%A2%E5%BE%AE%E4%BF%A1%E5%A5%BD%E5%8F%8B.html</url>
    <content type="text"><![CDATA[将使用itchat抓取微信数据，并对获取到的数据进行全面分析，包含好友性别、地理位置分布、个性签名等进行分析，分析到你怀疑人生。找到为什么单身的原因。 一、itchat简单介绍本文章用的主角库就是itchat。 itchat是一个开源的微信个人号接口，使用python调用微信从未如此简单。使用不到三十行的代码，你就可以完成一个能够处理所有信息的微信机器人。 本文章使用itchat分析一波微信好友 安装 1pip install itchat 基本的是使用方法本文章就不做介绍了，itchat的使用不是文章的主要内容。 正题开始 二、目的itchat抓取微信数据，并进行数据分析，数据可视化显示。 三、获取数据使用itchat中的 get_friends 方法获取微信所有好友数据 1234567def get_friends(): ''' 获取数据 ''' itchat.auto_login() friends = itchat.get_friends(update=True) return friends 四、处理数据处理获取到的数据，提前有用的数据 123456789101112131415161718192021222324252627282930313233def parse_data(data): ''' 提取有用的数据 该方法获取好友基本信息，且保存好友头像 ''' friends = [] base_path = './headImages' if not os.path.exists(base_path): os.mkdir(base_path) for item in data: img_data = itchat.get_head_img(userName=item['UserName']) img_name = item['RemarkName'] if item['RemarkName'] != '' else item['NickName'] img_name = re.sub("[\!\%\[\]\,\。\(\*\-\☻\*\)]", "", img_name)#剔除特殊字符 防止路径os报错 img_file = os.path.join(base_path, img_name+'.jpg') print(img_file) with open(img_file, 'wb') as f: f.write(img_data) friend = &#123; 'NickName': item['NickName'], 'RemarkName': item['RemarkName'], 'Sex': item['Sex'], 'Province': item['Province'], 'City': item['City'], 'Signature':item['Signature'].replace('\n',' ').replace(',', ' '), 'StarFriend': item['StarFriend'], 'ContactFlag': item['ContactFlag'] &#125; print(friend) friends.append(friend) return friends 五、保存数据将提取的到的数据保存成json文件，方便后面数据分析使用。 123456789101112def write_data(param): ''' 将数据写入文件中 ''' with open('./wx_friends.json', 'w', encoding='utf-8') as f: try: job_json = json.dumps(param, indent=4, ensure_ascii=False) f.write(job_json ) except Exception as e: print('-----') print(e) pass 六、分析数据，数据可视化使用pyechart分析微信好友数据。 pyechart安装 1pip install pyecharts 1、好友性别比例分析 12345678910111213141516171819202122232425262728293031323334def friends_sex(data): ''' 好友性别比列分析 ''' attr = ['male', 'woman', 'other'] male = 0 woman =0 unknown = 0 for item in data: if item['Sex'] == 0: unknown += 1 elif item['Sex'] == 1: male += 1 else: woman += 1 value = [male, woman, unknown] pie = Pie( '好友性格比例', '好友总人数：%d'%len(data), title_pos ='center' ) pie.add( '', attr, value, radius=[30,75], rosetype='area', is_label_show=True, is_legend_show=True, legend_top='bottom' ) pie.render('好友性别比例.html') 2、好友位置分布 12345678910111213141516171819202122232425262728def friends_address(data): cities = [] for item in data: if item['City'] != '': cities.append(item['City']) data = Counter(cities).most_common() print(data) geo = Geo( '好友位置分布', '', title_color="#fff", title_pos="center", width=1200, height=600, background_color="#404a59", ) attr, value = geo.cast(data) geo.add( "", attr, value, visual_range=[0, 200], maptype='china', visual_text_color="#fff", symbol_size=15, is_visualmap=True, ) geo.render('好友位置分布.html') 3、个人签名词云 12345678910111213141516171819202122232425262728293031323334353637def signature_cloud(data): ''' 个人签名词云 ''' signature = [] for item in data: if item['Signature'] != '': signature.append(item['Signature']) print(signature) data = jieba.cut(str(signature), cut_all=False) words = ' '.join(data) print(words) stopwords = STOPWORDS.copy() stopwords.add('span') stopwords.add('class') stopwords.add('emoji') stopwords.add('emoji1f42c') stopwords.add('emoji1f388') stopwords.add('emoji1f525') stopwords.add('emoji1f33c') stopwords.add('emoji1f483') stopwords.add('emoji2764') mask = np.array(Image.open('./love.png')) wc = WordCloud( width=1024, height=768, background_color='#fff', mask=mask, font_path='C:\Windows\Fonts\AdobeFangsongStd-Regular.otf', stopwords=stopwords, max_font_size=400, random_state=50 ) wc.generate_from_text(words) # 保存结果到本地 wc.to_file('个性签名词云图.jpg')]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xpath爬去boss直聘职位信息]]></title>
    <url>%2F20190215%2Fxpath%E7%88%AC%E5%8E%BBboss%E7%9B%B4%E8%81%98%E8%81%8C%E4%BD%8D%E4%BF%A1%E6%81%AF.html</url>
    <content type="text"><![CDATA[每年的年初都是招聘的旺季，想跳槽的小伙伴是否想了解一下相关行业使用的技术有哪些，哪些知识要学习的。 该文件只要是爬去boss直聘的相关职位信息，程序运行时只需要输入查询的城市，职位，爬去页数就可以把数据保存到json 文件中，用于分析。 实现功能 输入城市名，行政区名，职位，爬取的页面，将爬取数据保存为json文件，以便后期数据可视化分析， 该文章不做数据可视化分析。 该案例需要的库 1requests,re,json,os,lxml 一、目标网站1https://www.zhipin.com 二、分析网站1、根据城市查询某职位的信息 1https://www.zhipin.com/c101280600-p100103 分析可得 101280600 为查询城市的编号 2、根据城市名加行政区查询某职位的信息 1https://www.zhipin.com/c101280600-p100103/b_宝安区 分析可得 b_XX 其中XX为城市行政区 三、查询到城市编号并保存为json文件1、分析所有的请求 找到城市编号的数据来源 分析可得所有城市编号的数据来源链接为 1https://www.zhipin.com/common/data/city.json 城市编号爬取主要代码 123456789101112131415161718def query_city(): ''' 查询城市编号并保存 ''' url = 'https://www.zhipin.com/common/data/city.json' data = json.loads(send_request(url)) city = &#123;&#125; for item in data['data']['cityList']: for it in item['subLevelModelList']: city.update(&#123;it['name'] : it['code']&#125;) with open('./boss_city.json', 'w', encoding='utf-8') as f: try: json_str = json.dumps(city, indent=4, ensure_ascii=False) f.write(json_str) except Exception as e: print('-----') print(e) pass 四、程序编码1、加载程序用到的库以及全局变量定义 1234567891011121314# here put the import libimport requests,re,jsonimport osfrom lxml import etree #使用xpath语法解析base_url = "https://www.zhipin.com"headers = &#123; "User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/54.0.2840.99 Safari/537.36"&#125;# 正则表达式：去掉标签中的 和 标签，便于使用xpath解析提取文本regx_obj = re.compile(r'|&lt;(em).*?&gt;.*?&lt;!--\1--&gt;')city_code = None #城市编号city_region = None #城市行政区名 2、入口程序 123456789101112131415161718def main(): #全局变量修改需要global global city_code global city_region city_list = get_city_json() city_name = input('请输入需要爬取的城市:') city_code = city_list[city_name] city_region = input('请输入需要爬取的城市行政区:') work = input('请输入需要爬取的职业信息:') pages = int(input('请输入需要爬取的页面数:')) for page in range(1, pages + 1): start_work(page, work) if __name__ == "__main__": main() 3、获取每页数据中详细页的链接 12345678910111213141516171819202122232425def detail_url(params): ''' 获取详细页的页面链接 ''' if city_region is None: url_str = "c%s-p100103/?ka=sel-city-%s"%(city_code,city_code) else: url_str = "c%s-p100103/b_%s"%(city_code,city_region) job_url = '/'.join([base_url, url_str]) html = send_request(job_url, param=params) # 列表页页面 html_obj = etree.HTML(html) # 提取详情页url地址 nodes = html_obj.xpath(".//div[@class='info-primary']//a/@href") for node in nodes: url = '/'.join([base_url, node])# 拼接成完整的url地址 print(url) html = send_request(url) html_obj = etree.HTML(html) parse_data(html_obj) 4、xpath解析爬取的详细页数据 12345678910111213141516171819202122232425262728def parse_data(html_obj): ''' xpath 解析相关的数据 ''' # 解析为HTML文档 item = &#123;&#125; # 职位名 item['position'] = html_obj.xpath("//div[@class='job-primary detail-box']/div[@class='info-primary']/div[@class='name']/h1/text()")[0] # 发布者姓名 item['publisherName'] = html_obj.xpath("//div[@class='job-detail']//h2/text()")[0] # 发布者职位 item['publisherPosition'] = html_obj.xpath("//div[@class='detail-op']//p/text()")[0] # 薪水 item['salary'] = html_obj.xpath(".//div[@class='info-primary']//span[@class='salary']/text()")[0].strip() # 工作职责 item['responsibility'] = html_obj.xpath("//div[@class='job-sec']//div[@class='text']/text()")[0].strip() # 招聘要求 item['requirement'] = html_obj.xpath("//div[@class='job-primary detail-box']/div[@class='info-primary']/p/text()")[0] # 招聘企业 item['company'] = html_obj.xpath("//div[@class='sider-company']/div[@class='company-info']/a/@title")[0].strip() write_data(item) 5、保存解析的数据 123456789101112def write_data(param): ''' 将数据写入文件中 ''' with open('./job.json', 'a+', encoding='utf-8') as f: try: job_json = json.dumps(param, indent=4, ensure_ascii=False) f.write(job_json + ',') except Exception as e: print('-----') print(e) pass]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础整理之列表常见操作]]></title>
    <url>%2F20190210%2FPython%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%E4%B9%8B%E5%88%97%E8%A1%A8%E5%B8%B8%E8%A7%81%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[列表是最常用的Python数据类型，它可以作为一个方括号内的逗号分隔值出现。 列表的数据项不需要具有相同的类型 列表的格式1newList = ['A','B','C'] 常见操作方法添加元素1、append() 方法用于在列表末尾添加新的对象。 栗子 123456789101112li = ['A','B','C']print("-----添加之前，列表li的数据-----")for item in li: print(item) #提示、并添加元素tmp = input('请输入要添加的字母:')li.append(tmp)print("-----添加之后，列表li的数据-----")for item in li: print(item) 运行结果 12345678910-----添加之前，列表li的数据-----ABC请输入要添加的字母:D-----添加之后，列表li的数据-----ABCD 2、 extend() 函数用于在列表末尾一次性追加另一个序列中的多个值（用新列表扩展原来的列表） 栗子 1234ali = ['A', 'B', 'C']bli = ['D', 'E']ali.extend(bli)print(ali) 运行结果 1['A', 'B', 'C', 'D', 'E'] 3、 insert(index, object) 在指定位置index前插入元素object 栗子 123ali = ['A', 'B', 'C']ali.insert(1, 'D')print(ali) 运行结果 1['A', 'D', 'B', 'C'] 4、 count() 方法用于统计某个元素在列表中出现的次数。 栗子 123ali = ['A', 'B', 'C', 'A']count = ali.count('A')print(count) 运行结果 12 5、 index() 函数用于从列表中找出某个值第一个匹配项的索引位置。 栗子 12345ali = ['A', 'B', 'C', 'A']Aindex = ali.index('A')Cindex = ali.index('C')print('A 的索引位置：%s'%Aindex)print('C 的索引位置：%s'%Cindex) 运行结果 12A 的索引位置：0C 的索引位置：2 6、 pop() 函数用于移除列表中的一个元素（默认最后一个元素），并且返回该元素的值。 栗子 123456movie = ['加勒比海盗','骇客帝国','第一滴血','指环王','霍比特人','速度与激情']print('------删除之前------')print(movie)movie.pop()print('------删除之后------')print(movie) 运行结果 1234------删除之前------['加勒比海盗', '骇客帝国', '第一滴血', '指环王', '霍比特人', '速度与激情']------删除之后------['加勒比海盗', '骇客帝国', '第一滴血', '指环王', '霍比特人'] 7、 remove() 函数用于移除列表中某个值的第一个匹配项。 栗子 123456movie = ['加勒比海盗','骇客帝国','第一滴血','指环王','霍比特人','速度与激情']print('------删除之前------')print(movie)movie.remove('第一滴血')print('------删除之后------')print(movie) 运行结果 1234------删除之前------['加勒比海盗', '骇客帝国', '第一滴血', '指环王', '霍比特人', '速度与激情']------删除之后------['加勒比海盗', '骇客帝国', '指环王', '霍比特人', '速度与激情'] 8、 del根据下标进行删除 栗子 123456movie = ['加勒比海盗','骇客帝国','第一滴血','指环王','霍比特人','速度与激情']print('------删除之前------')print(movie)del movie[2]print('------删除之后------')print(movie) 运行结果 1234------删除之前------['加勒比海盗', '骇客帝国', '第一滴血', '指环王', '霍比特人', '速度与激情']------删除之后------['加勒比海盗', '骇客帝国', '指环王', '霍比特人', '速度与激情'] 9、 reverse() 函数用于反向列表中元素。 栗子 1234ali = ['A', 'B', 'C', 'D']print(ali)ali.reverse()print(ali) 运行结果 12['A', 'B', 'C', 'D']['D', 'C', 'B', 'A'] 10、 sort() 函数用于对原列表进行排序，如果指定参数，则使用比较函数指定的比较函数。 sort方法是将list按特定顺序重新排列，默认为由小到大，参数reverse=True可改为倒序，由大到小。 栗子 123456ali = ['A', 'B', 'C', 'D', 'F', 'E']print(ali)ali.sort()print(ali)ali.sort(reverse=True)print(ali) 运行结果 123['A', 'B', 'C', 'D', 'F', 'E']['A', 'B', 'C', 'D', 'E', 'F']['F', 'E', 'D', 'C', 'B', 'A']]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[多线程爬去英雄联盟所有英雄的皮肤]]></title>
    <url>%2F20190128%2F%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%88%AC%E5%8E%BB%E8%8B%B1%E9%9B%84%E8%81%94%E7%9B%9F%E6%89%80%E6%9C%89%E8%8B%B1%E9%9B%84%E7%9A%84%E7%9A%AE%E8%82%A4.html</url>
    <content type="text"><![CDATA[本文章利用Python中的多线程爬去英雄联盟官网所有英雄的皮肤。 该案例需要的库有： 1requests,re,json,threading 一、目标网站1https://lol.qq.com/data/info-heros.shtml 查找英雄皮肤的图片地址，并且分析格式 1234https://ossweb-img.qq.com/images/lol/web201310/skin/big266000.jpg #剑魔默认皮肤地址https://ossweb-img.qq.com/images/lol/web201310/skin/big266001.jpg #剑魔仲裁圣骑皮肤地址https://ossweb-img.qq.com/images/lol/web201310/skin/big84000.jpg #阿卡丽默认皮肤地址https://ossweb-img.qq.com/images/lol/web201310/skin/big84005.jpg #阿卡丽腥红之月鬼武姬皮肤地址 仔细分析发现皮肤连接中只有big后面的数据不一致，其他都一样。则说明所有皮肤的地址是 1https://ossweb-img.qq.com/images/lol/web201310/skin/big+数字+.jpg 分析266000和266001，84000和84005数字，每个英雄前几位数字相同，后三位都是从000开始的，分析得到后三位数字是每个英雄皮肤的序号 前面的数字是英雄id，只要找到所有英雄的id我们就可以找到所有英雄的所有皮肤地址。 二、查找所有英雄的id1、分析网站前端源码查找1没有找到 2、分析网站所有后端请求地址1也没有找到 3、分析网站的静态资源JavaScript1终于发现一个js文件存放英雄id 1https://lol.qq.com/biz/hero/champion.js 英雄id存放地址 三、程序编写现在皮肤地址有了，英雄的id也有了，开始程序代码编写 1、引入所需要的库12import requestsimport re,json,threading 2、程序入口12345678def main(): #所用英雄id请求地址 url = 'https://lol.qq.com/biz/hero/champion.js' ids_dict = get_lol_ids_dict(url) get_img(ids_dict) if __name__ == "__main__": main() 3、解析js文件提取英雄id和名称利用正则提取id和name 123456789def get_lol_ids_dict(url): headers = &#123; 'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:64.0) Gecko/20100101 Firefox/64.0' &#125; response = requests.get(url=url, headers=headers).text # ids_json = re.search('"keys":(.*),"data"', response).group(1)#group 第一个小括号内容 ids_dict = json.loads(ids_json) return ids_dict 4、拼接所有皮肤连接地址并保存1234567891011def get_img(ids_dict): start_url = 'https://ossweb-img.qq.com/images/lol/web201310/skin/big' for id,name in ids_dict.items(): #print(id,name) for k in range(13):#最多12张皮肤 url = start_url + id + '%03d'%k + '.jpg' #print(url) response = requests.get(url = url) if response.status_code == 200: with open('img/%s%d.jpg'%(name, k), 'wb') as f: f.write(response.content) 该方法下载皮肤速度太慢，改进程序，利用多线程下载皮肤 1234567891011121314151617181920def get_img(ids_dict): start_url = 'https://ossweb-img.qq.com/images/lol/web201310/skin/big' index = 0 for id,name in ids_dict.items(): #print(id,name) threads = []#多线程 for k in range(13):#最多12张皮肤 url = start_url + id + '%03d'%k + '.jpg' #print(url) response = requests.get(url = url) if response.status_code == 200: threads.append(threading.Thread(target = save_img, args = (url, name, k, index))) index += 1 #td = threading.Thread(target=save_img, args=(url,name, k)) #td.start() for td in threads: td.setDaemon(True) td.start() td.join() #父线程，等待所有线程结束 5、保存皮肤方法123456def save_img(url, name, k, index): response = requests.get(url = url) print(url) print('正在下载第%d张是【%s】的第%d张皮肤'%(index, name, k)) with open('img/%s%d.jpg'%(name, k), 'wb') as f: f.write(response.content) 到这一步我们的爬去皮肤的程序就结束了。]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
        <tag>多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python爬虫的基本思路]]></title>
    <url>%2F20190125%2FPython%E7%88%AC%E8%99%AB%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%80%9D%E8%B7%AF.html</url>
    <content type="text"><![CDATA[人生苦短，我用Python；本文章主要整理一下Python爬虫程序基本逻辑思路。以一个简单的爬虫程序为例 1、确定目标网站1https://bh.sb/post/category/main/&lt;/code&gt;&lt;/pre&gt; 2、分析被爬去网站数据来源结构，即分析数据请求url格式1url = 'https://bh.sb/post/category/main/page/2/'&lt;/code&gt;&lt;/pre&gt; 3、编写程序代码3.1、程序入口代码12if __name__ == "__main__": main()&lt;/code&gt;&lt;/pre&gt; 3.2、模拟浏览器请求数据利用requests模拟浏览器 12345678910def get_html(url): #添加headers头 headers = &#123; 'User-Agent':'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:64.0) Gecko/20100101 Firefox/64.0' &#125; response = requests.get(url, headers=headers); response.encoding = 'utf-8' if response.status_code == 200: return response.text return None&lt;/code&gt;&lt;/pre&gt; 其中添加headers用来模拟火狐浏览器，参数User-Agent也可以是谷歌浏览器或者其他浏览器 3.3、分析数据，通过解析方式，得到有用的数据12345678910111213#2、解析内容def parse_html(html, csv): soup = BeautifulSoup(html, 'lxml') data = soup.find_all('article') for item in data: #print(item.a.text) title = item.a.get_text() author = item.select('.text-muted.time')[0].get_text().split(' ')[0] img_href = item.select('img')[0].attrs['src'] note = item.select('.note')[0].get_text() li = [title, author, note, img_href]&lt;/code&gt;&lt;/pre&gt; 解析数据使用bs4,xPath等，这里使用bs4 从数据中解析出title，author，img_href，note等信息，存在列表li中 3.4、保存数据可以保存为文件或者保存到数据库中，该例子中保存到csv中 1234567#3、保存数据def init_csv(): #歌单csv文件 csv_file = open('1.csv', 'w', newline='', encoding='utf-8-sig') writer = csv.writer(csv_file) writer.writerow(['标题', '作者', '简介', '图片链接']) return writer&lt;/code&gt;&lt;/pre&gt; 最后一步进行数据分析以及可视化等。本文不做介绍]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[整理Yii2中定义的常用路径别名]]></title>
    <url>%2F20190123%2F%E6%95%B4%E7%90%86Yii2%E4%B8%AD%E5%AE%9A%E4%B9%89%E7%9A%84%E5%B8%B8%E7%94%A8%E8%B7%AF%E5%BE%84%E5%88%AB%E5%90%8D.html</url>
    <content type="text"><![CDATA[1@yii =&gt; C:\wamp\www\advanced\vendor\yiisoft\yii2&lt;/code&gt;&lt;/pre&gt; 表示Yii框架所在的目录，也是 yii\BaseYii 类文件所在的位置； 1@app =&gt; C:\wamp\www\advanced\frontend&lt;/code&gt;&lt;/pre&gt; 表示正在运行的应用的根目录；物理路径 1@vendor =&gt; C:\wamp\www\advanced/vendor&lt;/code&gt;&lt;/pre&gt; 表示Composer第三方库所在目录，一般是 @app/vendor 或 @app/../vendor ； 1@bower =&gt; C:\wamp\www\advanced/vendor\bower&lt;/code&gt;&lt;/pre&gt; 表示Bower第三方库所在目录，一般是 @vendor/bower ； 1@npm =&gt; C:\wamp\www\advanced\vendor\npm&lt;/code&gt;&lt;/pre&gt; 表示NPM第三方库所在目录，一般是 @vendor/npm ； 1@runtime =&gt; C:\wamp\www\advanced\frontend\runtime&lt;/code&gt;&lt;/pre&gt; 表示正在运行的应用的运行时用于存放运行时文件的目录，一般是 @app/runtime ； 1@webroot =&gt; C:/wamp/www/advanced/frontend/web&lt;/code&gt;&lt;/pre&gt; 表示正在运行的应用的入口文件 index.php 所在的目录，一般是 @app/web；物理路径 1@web =&gt; /advanced/frontend/web&lt;/code&gt;&lt;/pre&gt; URL别名，表示当前应用的根URL，主要用于前端。相对路径 1@common =&gt; C:/wamp/www/common/&lt;/code&gt;&lt;/pre&gt; 表示通用文件夹； 1@frontend =&gt; C:/wamp/www/advanced/frontend&lt;/code&gt;&lt;/pre&gt; 表示前台应用所在的文件夹； 1@backend =&gt; C:/wamp/www/advanced/&lt;/code&gt;&lt;/pre&gt; 表示后台应用所在的文件夹； 1@console =&gt; C:/wamp/www/console/&lt;/code&gt;&lt;/pre&gt; 表示命令行应用所在的文件夹；]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式之迭代器、代理模式]]></title>
    <url>%2F20190117%2FPHP%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E3%80%81%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、迭代器模式 迭代器模式，在不需要了解内部实现的前提下，遍历一个聚合对象的内部元素 相比传统的编程模式，迭代器模式可以隐藏遍历元素所需的操作 应用场景 遍历数据库表，拿到所有的user对象，然后用佛 foreach 循环，在循环的过程中修改某些字段的值。 实例代码：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990class MySQLis&#123; protected $conn; public function connect($host, $user, $pwd, $dbname)&#123; $this-&gt;conn = mysqli_connect($host, $user, $pwd, $dbname); &#125; public function query($sql)&#123; $res =mysqli_query($this-&gt;conn, $sql); return $res; &#125; public function close()&#123; mysqli_close($this-&gt;conn); &#125;&#125;class User&#123;//数据对象模式 public $id; public $name; public $tell; protected $db; public function __construct($id)&#123; $this-&gt;db = new MySQLis(); $this-&gt;db-&gt;connect('localhost', 'func', 'passwd', 'test'); $res = $this-&gt;db-&gt;query("select * from user where id = &#123;$id&#125; limit 1"); $data = $res-&gt;fetch_assoc(); $this-&gt;id = $data['id']; &#125; public function __destruct()&#123; $this-&gt;db-&gt;query("update user set name = '&#123;$this-&gt;name&#125;', tell = '&#123;$this-&gt;tell&#125;' where id= &#123;$this-&gt;id&#125;"); &#125;&#125;class Factory&#123;//工厂模式 public static function CreateAnimal($name)&#123; &#125; public static function getUser($id)&#123; $key = "user_&#123;$id&#125;"; $user = Register::get($key); if (!$user) &#123; $user = new User($id); Register::set($key, $user); &#125; return $user; &#125;&#125;class Register &#123;//注册器模式 protected static $object; public static function set($alias, $object)&#123; self::$object[$alias] = $object; &#125; public static function get($alias)&#123; return self::$object[$alias]; &#125; public static function _unset($alias)&#123; unset(self::$object[$alias]); &#125;&#125;class AllUser implements \Iterator&#123; protected $ids; protected $index; protected $data = array(); public function __construct()&#123; $db = new MySQLis(); $db-&gt;connect('localhost', 'func', 'passwd', 'test'); $res = $db-&gt;query('select id from user'); $this-&gt;ids = $res-&gt;fetch_all(MYSQLI_ASSOC); &#125; //返回当前索引游标指向的元素 public function current()&#123; $id = $this-&gt;ids[$this-&gt;index]['id']; return Factory::getUser($id); &#125; //移动当前索引游标到下一元素 public function next()&#123; $this-&gt;index ++; &#125; //返回当前索引游标指向的键 public function key()&#123; return $this-&gt;index; &#125; //判断当前索引游标指向的元素是否有效 public function valid()&#123; return $this-&gt;index &lt; count($this-&gt;ids); &#125; //重置索引游标 public function rewind()&#123; $this-&gt;index = 0; &#125;&#125;$user = new AllUser();foreach ($user as $key =&gt; $value) &#123; print_r($value);｝ 二、代理模式在客户端与实体之间建立一个代理对象(proxy)，客户端对实体进行操作全部委派代理对象，隐藏实体的具体实现细节； proxy还可以与业务代码分离，部署到另外的服务器。业务代码中通过RPC来委派任务 数据库主从，通过代理设置主从读写设置。 示例代码：1234567891011121314151617181920212223242526272829303132class MySQLis&#123; protected $conn; public function connect($host, $user, $pwd, $dbname)&#123; $this-&gt;conn = mysqli_connect($host, $user, $pwd, $dbname); &#125; public function query($sql)&#123; $res =mysqli_query($this-&gt;conn, $sql); return $res; &#125; public function close()&#123; mysqli_close($this-&gt;conn); &#125;&#125;class Proxy implements IUserProxy&#123; public function getUserName($id)&#123; $db = new MySQLis(); $db-&gt;connect('localhost', 'func', 'passwd', 'test'); $db-&gt;query('select * from user where id='.$id); &#125; public function setUserName($id, $name)&#123; $db = new MySQLis(); $db-&gt;connect('localhost', 'func', 'passwd', 'test'); $db-&gt;query("update user set name= '&#123;$name&#125;' where id= &#123;$id&#125;"); &#125;&#125;interface IUserProxy&#123; public function getUserName($id); public function setUserName($id, $name);&#125;$proxy = new Proxy();$proxy-&gt;getUserName(1);$proxy-&gt;setUserName(1, 'admin');]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式之观察者、原型以及装饰模式]]></title>
    <url>%2F20190117%2FPHP%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E3%80%81%E5%8E%9F%E5%9E%8B%E4%BB%A5%E5%8F%8A%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、观察者模式 观察者模式（ Observer ），当一个对象状态发生改变时，依赖它的对象全部会收到通知，并自动更新。 场景：一个事件发生后，要执行一连串更新操作。传统的编程方式，就是在事件的代码之后直接加入处理逻辑。当更新的逻辑增多后，代码会变得难以维护。 这种方式是耦合的，入侵式的，增加新的逻辑需要修改事件主体的代码。 观察者模式实现了低耦合，非入侵式的通知与更新机制。 实例代码：1234567891011121314151617181920212223242526272829303132333435abstract class EventGenerator&#123; private $observers = array(); public function addObsserver($observer)&#123; $this-&gt;observers[] = $observer; &#125; public function notify()&#123; foreach ($this-&gt;observers as $key =&gt; $observer) &#123; $observer-&gt;update(); &#125; &#125;&#125;interface Observer&#123; public function update($event_info = null);&#125;class Event extends EventGenerator&#123; public function trigger()&#123; echo "事件发生"; //update code $this-&gt;notify(); &#125;&#125;class ObserverOne implements Observer&#123; public function update($event_info = null)&#123; echo "逻辑1"; &#125;&#125;class ObserverTwo implements Observer&#123; public function update($event_info = null)&#123; echo "逻辑2"; &#125;&#125;$event = new Event();$event-&gt;addObsserver(new ObserverOne);$event-&gt;addObsserver(new ObserverTwo);$event-&gt;trigger(); 二、原型模式 与工厂模式作用类似，都是用来创建对象。 与工厂模式的实现不懂，原型模式是首先创建好一个原型对象，然后通过clone原型对象来创建新的对象。这样就免去了类创建是重复的初始化操作。 原型模式适用于大对象的创建。创建一个大对象需要很大的开销，如果每次new就会消耗很大，原型模式仅需内存拷贝即可。 实例代码：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Canvas&#123; public $data; protected $decorators = array(); public function init($width = 20, $height = 10)&#123; $data = array(); for($i = 0; $i &lt; $height; $i++)&#123; for($j = 0; $j &lt; $width; $j++)&#123; $data[$i][$j] = '*'; &#125; &#125; $this-&gt;data = $data; &#125; public function draw()&#123; foreach($this-&gt;data as $line)&#123; foreach($line as $char) &#123; echo $char; &#125; echo "\n"; &#125; &#125; public function rect($a1, $a2, $b1, $b2)&#123; foreach($this-&gt;data as $k1 =&gt; $line)&#123; if ($k1 &lt; $a1 or $k1 &gt; $a2) continue; foreach($line as $k2 =&gt; $char)&#123; if ($k2 &lt; $b1 or $k2 &gt; $b2) continue; $this-&gt;data[$k1][$k2] = ' '; &#125; &#125; &#125;&#125;/** * 创建原型对象 * [$prototype description] * @var Canvas */$prototype = new Canvas();$prototype-&gt;init();$canvas = clone $prototype;//克隆原型对象$canvas-&gt;rect(3, 6, 4, 12);$canvas-&gt;draw();echo "--------------";$canvas1 = clone $prototype;$canvas1-&gt;rect(3, 3, 3, 3);$canvas1-&gt;draw(); 三、装饰模式1.装饰模式,可以动态的添加修改类的功能。 2.一个类提供了一项功能,如果要在修改并添加额外的功能,传统的编程模式,需要写一个之类集成它,并重新实现类的方法。 3.使用装饰模式,仅需在运行时添加一个装饰对象即可实现,可以实现最大的灵活性。 实例代码： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182class Canvas&#123; public $data; protected $decorators = array(); public function init($width = 20, $height = 10)&#123; $data = array(); for($i = 0; $i &lt; $height; $i++)&#123; for($j = 0; $j &lt; $width; $j++)&#123; $data[$i][$j] = '*'; &#125; &#125; $this-&gt;data = $data; &#125; public function addDecorator($decorator)&#123; $this-&gt;decorators[] = $decorator; &#125; public function beforeDraw()&#123; foreach($this-&gt;decorators as $decorator)&#123; $decorator-&gt;beforeDraw(); &#125; &#125; public function afterDraw()&#123; $decorators = array_reverse($this-&gt;decorators); foreach($decorators as $decorator)&#123; $decorator-&gt;afterDraw(); &#125; &#125; public function draw()&#123; $this-&gt;beforeDraw(); foreach($this-&gt;data as $line)&#123; foreach($line as $char) &#123; echo $char; &#125; echo "\n"; &#125; $this-&gt;afterDraw(); &#125; public function rect($a1, $a2, $b1, $b2)&#123; foreach($this-&gt;data as $k1 =&gt; $line)&#123; if ($k1 &lt; $a1 or $k1 &gt; $a2) continue; foreach($line as $k2 =&gt; $char)&#123; if ($k2 &lt; $b1 or $k2 &gt; $b2) continue; $this-&gt;data[$k1][$k2] = ' '; &#125; &#125; &#125;&#125;interface DrawDecorator&#123; public function beforeDraw(); public function afterDraw();&#125;class ColorDrawDecotator implements DrawDecorator&#123; protected $color; public function __construct($color = 'red')&#123; $this-&gt;color = $color; &#125; public function beforeDraw()&#123; echo "+++++++++++"; &#125; public function afterDraw()&#123; echo "-----------"; &#125;&#125;class SizeDrawDecotator implements DrawDecorator&#123; protected $size; public function __construct($size = '12px')&#123; $this-&gt;size = $size; &#125; public function beforeDraw()&#123; echo "before draw"; &#125; public function afterDraw()&#123; echo "after draw"; &#125;&#125;$canvas = new Canvas();$canvas-&gt;init();$canvas-&gt;addDecorator(new ColorDrawDecotator('green'));$canvas-&gt;addDecorator(new SizeDrawDecotator('24px'));$canvas-&gt;rect(3, 6, 4, 12);$canvas-&gt;draw();]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式之适配、策略以及数据对象映射模式]]></title>
    <url>%2F20190117%2FPHP%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E3%80%81%E7%AD%96%E7%95%A5%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E5%AF%B9%E8%B1%A1%E6%98%A0%E5%B0%84%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、适配器模式1、可以将截然不同的函数接口封装成统一的API 2、实际应用举例：PHP的数据库操作有mysql/mysqli/pdo三种，可以用适配器模式统一成一致。 类似的场景还有cache适配器，可以将memcache/redis/file/apc等不同的缓存函数统一成一致的接口。 实例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950interface IDataBase&#123;//接口 统一api的方式 public function connect($host, $user, $pwd, $dbname); public function query($sql); public function close();&#125;class MySQL implements IDataBase&#123; protected $conn; public function connect($host, $user, $pwd, $dbname)&#123; $this-&gt;conn = mysql_connect($host, $user, $pwd); mysql_select_db($dbname, $this-&gt;conn); &#125; public function query($sql)&#123; $res =mysql_query($sql, $this-&gt;conn); return $res; &#125; public function close()&#123; mysql_close(); &#125;&#125;class MySQLis implements IDataBase&#123; protected $conn; public function connect($host, $user, $pwd, $dbname)&#123; $this-&gt;conn = mysqli_connect($host, $user, $pwd, $dbname); &#125; public function query($sql)&#123; $res =mysqli_query($this-&gt;conn, $sql); return $res; &#125; public function close()&#123; mysqli_close($this-&gt;conn); &#125;&#125;class PDOs implements IDataBase&#123; protected $conn; public function connect($host, $user, $pwd, $dbname)&#123; $this-&gt;conn = new \PDO("mysql://host=$host; dbname=$dbname", $user, $pwd); &#125; public function query($sql)&#123; $res = $this-&gt;conn-&gt;query($sql); return $res; &#125; public function close()&#123; unset($this-&gt;conn); &#125;&#125;$db = new MySQLis();$db-&gt;connect('localhost', 'root', 'root', 'test');$res = $db-&gt;query('show tables');$db-&gt;close();var_dump($res); 二、策略模式：分支逻辑处理 1、策略模式，将一组特定的行为和算法封装成类，以适应某些特定的上下文环境， 这种模式就是策略模式 2、实际应用举例，假如一个电商网站系统， 针对男性女性用户要各自跳转到不同的商品类名，并且所有广告位展示不同的广告， 传统的做法是加入if…else… 判断。如果新增加一种用户类型，只需要新增加一种策略即可 实例代码： 12345678910111213141516171819202122232425262728293031323334353637383940interface Strategy&#123; public function showAd(); public function showCategory();&#125;class GrilStrategy implements Strategy&#123; public function showAd()&#123; echo "新款女装"; &#125; public function showCategory()&#123; echo "女装"; &#125;&#125;class BoyStrategy implements Strategy&#123; public function showAd()&#123; echo "新款男装"; &#125; public function showCategory()&#123; echo "男装"; &#125;&#125;class Page&#123; protected $strategy; public function index()&#123; echo "AD:"; $this-&gt;strategy-&gt;showAd(); echo "categray:"; $this-&gt;strategy-&gt;showCategory(); &#125; public function setStrategy($strategy)&#123; $this-&gt;strategy = $strategy; &#125;&#125;$page = new Page();if (isset($_GET['gril'])) &#123; $strategy = new GrilStrategy();&#125;else&#123; $strategy = new BoyStrategy();&#125;$page-&gt;setStrategy($strategy);$page-&gt;index(); 三、数据对象映射模式1、数据对象映射模式，是将对象和数据存储映射起来，对一个对象的操作会映射为对数据存储的操作，比我们在代码中new一个对象，那么使用该模式就可以将对对象的一些操作， 比如说我们设置的一些属性，它就会自动保存到数据库，跟数据库中表的一条记录对应起来。 实例，在代码中实现数据对象映射模式，我们将写一个ORM类，将复杂的SQL语句映射成对象属性的操作结合使用数据对象映射模式，工厂模式，注册模式。 2、对象关系映射（英语：Object Relation Mapping，简称ORM，或O/RM，或O/R mapping），是一种程序技术，用于实现面向对象编程语言里不同类型系统的数据之间的转换 。 从效果上说，它其实是创建了一个可在编程语言里使用的–“虚拟对象数据库”。 面向对象是从软件工程基本原则（如耦合、聚合、封装）的基础上发展起来的，而关系数据库则是从数学理论发展而来的，两套理论存在显著的区别。为了解决这个不匹配的现象， 对象关系映射技术应运而生。 简单的说：ORM相当于中继数据。 示例代码： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071class MySQLis&#123; protected $conn; public function connect($host, $user, $pwd, $dbname)&#123; $this-&gt;conn = mysqli_connect($host, $user, $pwd, $dbname); &#125; public function query($sql)&#123; $res =mysqli_query($this-&gt;conn, $sql); return $res; &#125; public function close()&#123; mysqli_close($this-&gt;conn); &#125;&#125;class User&#123;//数据对象模式 public $id; public $name; public $tell; protected $db; public function __construct($id)&#123; $this-&gt;db = new MySQLis(); $this-&gt;db-&gt;connect('localhost', 'func', 'passwd', 'test'); $res = $this-&gt;db-&gt;query("select * from user where id = &#123;$id&#125; limit 1"); $data = $res-&gt;fetch_assoc(); $this-&gt;id = $data['id']; /*$this-&gt;id = $data['id']; $this-&gt;name = $data['name']; $this-&gt;tell = $data['tell'];*/ &#125; public function __destruct()&#123; $this-&gt;db-&gt;query("update user set name = '&#123;$this-&gt;name&#125;', tell = '&#123;$this-&gt;tell&#125;' where id= &#123;$this-&gt;id&#125;"); &#125;&#125;class Factory&#123;//工厂模式 public static function CreateAnimal($name)&#123; &#125; public static function getUser($id)&#123; $key = "user_&#123;$id&#125;"; $user = Register::get($key); if (!$user) &#123; $user = new User($id); Register::set($key, $user); &#125; return $user; &#125;&#125;class Register &#123;//注册器模式 protected static $object; public static function set($alias, $object)&#123; self::$object[$alias] = $object; &#125; public static function get($alias)&#123; return self::$object[$alias]; &#125; public static function _unset($alias)&#123; unset(self::$object[$alias]); &#125;&#125;class Page&#123; public function index()&#123; $user = Factory::getUser(1); $user-&gt;name = 'admin110'; $this-&gt;test(); echo "ok"; &#125; public function test()&#123; $user = Factory::getUser(1); $user-&gt;tell = '10010'; &#125;&#125;$page = new Page();$page-&gt;index();]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP设计模式之基础设计模式]]></title>
    <url>%2F20190117%2FPHP%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%9F%BA%E7%A1%80%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[一、工厂模式属于类创建型模式，在简单工厂模式中，可以根据参数的不同返回不同类的实例，简单工厂模式专门定义一个类来负责创建其他类的实例， 被创建的实例通常都具有共同的父类。 代码实例：12345678910111213141516171819202122class Cat&#123; function __construct()&#123; echo "I am Cat class "; &#125;&#125;class Dog&#123; function __construct()&#123; echo "I am Dog class "; &#125;&#125;class Factory&#123; public static function CreateObject($name)&#123; if ($name == 'cat') &#123; return new Cat(); &#125;elseif ($name == 'dog') &#123; return new Dog(); &#125; &#125;&#125;$cat = Factory::CreateObjectl('cat');$dog = Factory::CreateObject('dog'); 优点：实现对象的创建和对象使用的分离，将对象的创建交给专门的工厂类负责；一旦发生变更，只需要在工厂类里面修改即可，而不用一个一个的去修改。 缺点：工厂类不够灵活，增加新的具体产品需要修改工厂类的判断逻辑代码，产品较多时。工厂方法代码非常复杂。 二、单例模式是一种常用的软件设计模式。在应用这个模式时，单例对象的类必须保证只有一个实例存在。许多时候整个系统只需要拥有一个的全局对象， 这样有利于我们协调系统整体的行为。防止对象多次连接，造成资源浪费。 示例代码： 1234567891011121314151617181920class DataBase&#123; private static $instance; private function __construct()&#123;&#125;//私有构造方法 禁止使用new创建对象 public static function getInstance()&#123; if (!isset(self::$instance)) &#123; self::$instance = new self; &#125; return self::$instance; &#125; private function __clone()&#123;&#125;//将克隆方法设为私有，禁止克隆对象 public function say()&#123; echo "这是用单例模式创建对象实例 "; &#125; public function operation()&#123; echo "这里可以添加其他方法和操作 "; &#125;&#125;$db = DataBase::getInstance();$db-&gt;say();$db-&gt;operation(); 三、注册器模式已经创建好对象后，下次使用直接取，将一些对象注册到全局树上面，可以用来在任何地方被访问。一般只提供一个set 和 unset 两种方法， 需要一个静态的非公开属性和一个取得静态属性的静态方法. 实例代码： 123456789101112131415161718192021222324252627282930313233class Register &#123;//注册器模式 protected static $object; public static function set($alias, $object)&#123; self::$object[$alias] = $object; &#125; public static function get($alias)&#123; return self::$object[$alias]; &#125; public static function _unset($alias)&#123; unset(self::$object[$alias]); &#125;&#125;class Factory&#123;//工厂模式 public static function createObject()&#123; $db = DataBase::getInstance(); Register::set('db', $db); &#125;&#125;class DataBase&#123;//单例模式 protected static $instance; public static function getInstance()&#123; if (!isset(self::$instance)) &#123; self::$instance = new self; &#125; return self::$instance; &#125; public function say()&#123; echo "这是用单例模式创建对象实例 "; &#125;&#125;$db = Factory::createObject();$obj = Register::get('db');$obj-&gt;say();]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>设计模式</tag>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript自定义滚动条]]></title>
    <url>%2F20190117%2FJavaScript%E8%87%AA%E5%AE%9A%E4%B9%89%E6%BB%9A%E5%8A%A8%E6%9D%A1.html</url>
    <content type="text"><![CDATA[一、主要HTML代码： 二、主要的CSS样式 三、面向对象的形式书写javaScript1、创建滚动条方法：12345function createScroll() &#123; this.doc = document; this._wheelData = -1; this.init.apply(this, arguments); &#125; 2、初始化滚动条：123456789init: function(mainBox, contentBox, className) &#123; var mainBox = this.doc.getElementById(mainBox); var contentBox = this.doc.getElementById(contentBox); var scrollDiv = this._createScroll(mainBox, className); this._resizeScorll(scrollDiv, mainBox, contentBox); this._tragScroll(scrollDiv, mainBox, contentBox); this._wheelChange(scrollDiv, mainBox, contentBox); this._clickScroll(scrollDiv, mainBox, contentBox); &#125;, 3、创建滚动条基本元素：1234567891011_createScroll: function(mainBox, className) &#123; var _scrollBox = this.doc.createElement('div') var _scroll = this.doc.createElement('div'); var span = this.doc.createElement('span'); _scrollBox.appendChild(_scroll); _scrollBox.className = 'scroll'; _scroll.appendChild(span); _scroll.className = className; mainBox.appendChild(_scrollBox); return _scroll; &#125;, 4、页面加载调整滚动条：12345678910111213141516171819_resizeScorll: function(element, mainBox, contentBox) &#123; var eleNode = element.parentNode; var conHeight = contentBox.offsetHeight; var _width = mainBox.clientWidth; var _height = mainBox.clientHeight; var _scrollWidth = element.offsetWidth; var _left = _width - _scrollWidth; eleNode.style.width = _scrollWidth + "px"; eleNode.style.height = _height + "px"; eleNode.style.left = _left + "px"; eleNode.style.position = "absolute"; eleNode.style.background = "#ccc"; contentBox.style.width = (mainBox.offsetWidth - _scrollWidth + 10) + "px"; var _scrollHeight = parseInt(_height * (_height / conHeight)); if (_scrollHeight &gt;= mainBox.clientHeight) &#123; element.parentNode.style.display = "none"; &#125; element.style.height = _scrollHeight + "px";&#125;, 5、定义鼠标拖动滚动条方法：12345678910111213141516171819202122232425262728293031323334_tragScroll: function(element, mainBox, contentBox) &#123; var mainHeight = mainBox.clientHeight; element.onmousedown = function(event) &#123; var _this = this; var _scrollTop = element.offsetTop; var e = event || window.event; var top = e.clientY; //this.onmousemove=scrollGo; document.onmousemove = scrollGo; document.onmouseup = function(event) &#123; this.onmousemove = null; &#125; function scrollGo(event) &#123; var e = event || window.event; var _top = e.clientY; var _t = _top - top + _scrollTop; if (_t &gt; (mainHeight - element.offsetHeight)) &#123; _t = mainHeight - element.offsetHeight; &#125; if (_t &lt;= 0) &#123; _t = 0; &#125; element.style.top = _t + "px"; contentBox.style.top = -_t * (contentBox.offsetHeight / mainBox.offsetHeight) + "px"; this._wheelData = _t; &#125; &#125; element.onmouseover = function() &#123; this.style.background = "#1b4f63"; &#125; element.onmouseout = function() &#123; this.style.background = "#2c8cab"; &#125;&#125;, 6、定义鼠标滚轮滚动，滚动条滚动：1234567891011121314151617181920212223242526272829_wheelChange: function(element, mainBox, contentBox) &#123; var node = typeof mainBox == "string" ? $(mainBox) : mainBox; var flag = 0, rate = 0, wheelFlag = 0; if (node) &#123; this._mouseWheel(node, function(data) &#123; wheelFlag += data; if (this._wheelData &gt;= 0) &#123; flag = this._wheelData; element.style.top = flag + "px"; wheelFlag = this._wheelData * 12; this._wheelData = -1; &#125; else &#123; flag = wheelFlag / 12; &#125; if (flag &lt;= 0) &#123; flag = 0; wheelFlag = 0; &#125; if (flag &gt;= (mainBox.offsetHeight - element.offsetHeight)) &#123; flag = (mainBox.clientHeight - element.offsetHeight); wheelFlag = (mainBox.clientHeight - element.offsetHeight) * 12; &#125; element.style.top = flag+ "px"; contentBox.style.top = -flag * (contentBox.offsetHeight / mainBox.offsetHeight) + "px"; &#125;); &#125;&#125;, 7、定义鼠标点击滚动条方法：123456789101112131415161718192021_clickScroll: function(element, mainBox, contentBox) &#123; var eleNode = element.parentNode; eleNode.onclick = function(event) &#123; var e = event || window.event; var t = e.target || e.srcElement; var sTop = document.documentElement.scrollTop &gt; 0 ? document.documentElement.scrollTop : document.body.scrollTop; var top = mainBox.offsetTop; var _top = e.clientY + sTop - top - element.offsetHeight / 2; if (_top &lt;= 0) &#123; _top = 0; &#125; if (_top &gt;= (mainBox.clientHeight - element.offsetHeight)) &#123; _top = mainBox.clientHeight - element.offsetHeight; &#125; if (t != element) &#123; element.style.top = _top + "px"; contentBox.style.top = -_top * (contentBox.offsetHeight / mainBox.offsetHeight) + "px"; this._wheelData = _top; &#125; &#125;&#125;, 8、方法调用1new createScroll('box', 'content', 'scrollDiv');]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[利用three.js在网页嵌入dae类型的3d模型]]></title>
    <url>%2F20190117%2F%E5%88%A9%E7%94%A8three.js%E5%9C%A8%E7%BD%91%E9%A1%B5%E5%B5%8C%E5%85%A5dae%E7%B1%BB%E5%9E%8B%E7%9A%843d%E6%A8%A1%E5%9E%8B.html</url>
    <content type="text"><![CDATA[1、主要的html代码 2、静态样式123456789/* 模型样式 */#glFullscreen &#123;width: 100%;height: 66%;min-width: 640px;min-height: 360px;position: relative;overflow: hidden;z-index: 0;&#125;#glFullscreen canvas &#123;width: 100%;height: 100%;top: 0;left: 0;background-color: #000000; &#125;/* 模型控制按钮样式 */#button&#123;z-index: 100;position: absolute;bottom: 33%;right: 5px;cursor: pointer;&#125;#button .button &#123;background: #1b4f63;width: 50px;border-radius: 3px;margin: 5px;float: left;&#125;#button .button p&#123;font-family: &apos;Roboto&apos;; text-align: center;text-transform: uppercase;font-size: 14px;color: #FFF;user-select: none;line-height: 16px;padding: 5px 0;margin: 0;&#125;#button .button p:hover&#123;cursor: pointer;&#125;#button .button p:after&#123;content: &quot;&quot;;display: block;width: 100%;border-radius: 50%;background-color: darken(#f1c40f, 20%);opacity: 0.4;&#125; 2、Javascript代码讲解a、获取dom对象方法1234//获取dom对象function getDom()&#123; container = document.getElementById('glFullscreen'); &#125; b、模型加载方法12345678910111213141516171819202122//模型加载function initLoader()&#123; var loader = new THREE.ColladaLoader(); loader.load('model/demo.DAE', function(collada)&#123; dae = collada.scene; dae.traverse(function(child)&#123; if (child instanceof THREE.Mesh) &#123; child.material.flatShading = true; &#125; &#125;); //设置模型的位置 dae.position.x = 4.1; dae.position.y = 8; dae.position.z = 1.8; //调整模型的大小 dae.scale.x = dae.scale.y = dae.scale.z = 0.05; dae.updateMatrix(); kinematics = collada.kinematics; scene.add(dae); setupTween(); &#125;); &#125; c、创建相机方法1234567//创建相机function createCamera(posX, posY, posZ)&#123; camera = new THREE.PerspectiveCamera( 45, 1, 0.1, 10000 ); camera.position.copy(new THREE.Vector3( 20, 10, 30 )); camera.lookAt( new THREE.Vector3( 0, 5, 0) ); //camera.position.set( posX, posY, posZ );&#125; d、模型控制方法123456789101112131415161718192021//轨迹控制 鼠标按下左右移动， 滚轮远近function initControl()&#123; controls = new THREE.OrbitControls( camera, renderer.domElement ); // 如果使用animate方法时，将此函数删除 //controls.addEventListener( 'change', render ); // 使动画循环使用时阻尼或自转 意思是否有惯性 controls.enableDamping = true; //动态阻尼系数 就是鼠标拖拽旋转灵敏度 //controls.dampingFactor = 0.25; //是否可以缩放 controls.enableZoom = true; //是否自动旋转 controls.autoRotate = true; controls.autoRotateSpeed = 0.5; //设置相机距离原点的最远距离 controls.minDistance = 10; //设置相机距离原点的最远距离 controls.maxDistance = 600; //是否开启右键拖拽 controls.enablePan = false;&#125; e、初始化场景1234//初始场景function initScene()&#123; scene = new THREE.Scene();&#125; f、创建网格12345//创建网格function createGrid()&#123; var grid = new THREE.GridHelper( 20, 20 ); scene.add( grid );&#125; g、设置光照123456789//设置光照function setLight()&#123; particleLight = new THREE.Mesh( new THREE.SphereGeometry( 4, 8, 8 ), new THREE.MeshBasicMaterial( &#123; color: 0xffffff &#125; ) ); var light = new THREE.HemisphereLight( 0xffeeee, 0x111122 ); var pointLight = new THREE.PointLight( 0xffffff, 0.3 ); //scene.add( particleLight ); scene.add( light ); //particleLight.add( pointLight );&#125; h、创建渲染器1234567891011//创建webglr层function initRenderer()&#123; var params = &#123; antialias:true &#125;; renderer = new THREE.WebGLRenderer(params); renderer.setPixelRatio( window.devicePixelRatio ); renderer.setSize( window.innerWidth, window.innerHeight ); renderer.setClearColor( 0x103f51 ); container.appendChild( renderer.domElement );&#125; i、创建性能监视器12345//创建监视器function createStats()&#123; stats = new Stats(); //container.appendChild( stats.dom );&#125; j、模型动作解析12345678910111213141516171819202122232425262728//模型动画function setupTween() &#123; var duration = THREE.Math.randInt( 1000, 5000 ); var target = &#123;&#125;; for ( var prop in kinematics.joints ) &#123; if ( kinematics.joints.hasOwnProperty( prop ) ) &#123; if ( ! kinematics.joints[ prop ].static ) &#123; var joint = kinematics.joints[ prop ]; var old = tweenParameters[ prop ]; var position = old ? old : joint.zeroPosition; tweenParameters[ prop ] = position; target[ prop ] = THREE.Math.randInt( joint.limits.min, joint.limits.max ) &#125; &#125; &#125; kinematicsTween = new TWEEN.Tween( tweenParameters ).to( target, duration ).easing( TWEEN.Easing.Quadratic.Out ); kinematicsTween.onUpdate( function() &#123; for ( var prop in kinematics.joints ) &#123; if ( kinematics.joints.hasOwnProperty( prop ) ) &#123; if ( ! kinematics.joints[ prop ].static ) &#123; kinematics.setJointValue( prop, this[ prop ] ); &#125; &#125; &#125; &#125; ); kinematicsTween.start(); setTimeout( setupTween, duration ); &#125; k、模型动画12345678910function animate() &#123; /*requestAnimationFrame( animate ); render(); stats.update(); TWEEN.update();*/ stats.update(); TWEEN.update(); controls.update(); renderer.render(scene, camera);&#125; l、使模型旋转12345678910function render() &#123; var timer = Date.now() * 0.0001; camera.lookAt( new THREE.Vector3( 0, 5, 0) ); particleLight.position.x = Math.sin( timer * 4 ) * 3009; particleLight.position.y = Math.cos( timer * 5 ) * 4000; particleLight.position.z = Math.cos( timer * 4 ) * 3009; //更新控制器 controls.update(); renderer.render( scene, camera );&#125; m、窗口大小监听123456window.addEventListener( 'resize', onWindowResize, false );function onWindowResize() &#123; //camera.aspect = container.clientWidth / container.clientHeight; camera.updateProjectionMatrix(); renderer.setSize( window.innerWidth, window.innerHeight );&#125; n、按钮控制模型12345678910111213141516171819202122232425262728293031323334function resetObj()&#123; //是否自动旋转 controls.autoRotate = true; camera.position.copy(new THREE.Vector3( 20, 10, 30 )); //animate(); &#125; function frontObj()&#123; //是否自动旋转 controls.autoRotate = false; camera.position.copy(new THREE.Vector3( 0.0, 10, 20.0 )); //createCamera(20, 10, 50); //animate(); &#125; function backObj()&#123; //是否自动旋转 controls.autoRotate = false; camera.position.copy(new THREE.Vector3( 0.0, 10, -20.0 )); //animate();&#125;function threeStart()&#123; initLoader(); getDom(); createCamera(20, 10,30); initScene(); createGrid(); setLight(); initRenderer(); initControl(); createStats(); //setupTween(); //animate(); setInterval(animate, parseInt(1000 / frameCount)); &#125;threeStart();]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
        <tag>three.js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript常见算法排序之冒泡排序]]></title>
    <url>%2F20190117%2FJavaScript%E5%B8%B8%E8%A7%81%E7%AE%97%E6%B3%95%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[1、算法原理冒泡排序是一种简单的排序算法。 它重复地走访过要排序的数列，一次比较两个元素，如果它们的顺序错误就把它们交换过来。 走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。 2、算法流程（1）比较相邻的元素。 如果第一个比第二个大，就交换它们两个。 （2）对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。 在这一点，最后的元素应该会是最大的数。 （3）针对所有的元素重复以上的步骤，除了最后一个。 （4）持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较 3、实例分析以数组 arr = [5, 1, 4, 2, 8] 为例说明： 第一次外循环1234567( 5 1 4 2 8 ) → ( 1 5 4 2 8 )， 5 &gt; 1 交换位置( 1 5 4 2 8 ) → ( 1 4 5 2 8 )， 5 &gt; 4 交换位置( 1 4 5 2 8 ) → ( 1 4 2 5 8 )， 5 &gt; 2 交换位置( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 5 &lt; 8 位置不变 第二次外循环（除开最后一个元素8，对剩余的序列）12345( 1 4 2 5 8 ) → ( 1 4 2 5 8 )， 1 &lt; 4 位置不变( 1 4 2 5 8 ) → ( 1 2 4 5 8 )， 4 &gt; 2 交换位置( 1 2 4 5 8 ) → ( 1 2 4 5 8 )， 4 &lt; 5 位置不变 第三次外循环（除开已经排序好的最后两个元素，可以注意到上面的数组其实已经排序完成，但是程序本身并不知道， 所以还要进行后续的循环，直到剩余的序列为 1）123( 1 2 4 5 8 ) → ( 1 2 4 5 8 )( 1 2 4 5 8 ) → ( 1 2 4 5 8 ) 第四次外循环（最后一次）1( 1 2 4 5 8 ) → ( 1 2 4 5 8 ) 4、代码实现12345678910111213function bubbleSort(array)&#123; var temp; for(var i = array.length; 0 &lt; i; i --)&#123; for(var j = 0; j &lt; i; j ++)&#123; if (array[j] &gt; array[j + 1]) &#123; temp = array[j]; array[j] = array[j + 1]; array[j + 1] = temp; &#125; &#125; &#125; return array;&#125;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
        <tag>冒泡</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript常见排序之快速排序]]></title>
    <url>%2F20190117%2FJavaScript%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F.html</url>
    <content type="text"><![CDATA[1、算法原理将原问题分解为若干个规模更小但结构与原问题相似的子问题。 递归地解这些子问题，然后将这些子问题的解组合为原问题的解。 2、排序流程（1）在数据集之中，选择一个元素作为” 基准” （pivot）。 （2）所有小于” 基准” 的元素，都移到” 基准” 的左边；所有大于” 基准” 的元素，都移到” 基准” 的右边。 这个操作称为分区 (partition) 操作，分区操作结束后，基准元素所处的位置就是最终排序后它的位置。 （3）对” 基准” 左边和右边的两个子集，不断重复第一步和第二步，直到所有子集只剩下一个元素为止。 3、实例分析举例来说，现有数组 arr = [3,7,8,5,2,1,9,5,4]，分区可以分解成以下步骤： （1）首先选定一个基准元素，这里我们元素 5 为基准元素（基准元素可以任意选择）： 123 pivot ↓3 7 8 5 2 1 9 5 4 （2）将基准元素与数组中最后一个元素交换位置，如果选择最后一个元素为基准元素可以省略该步： 123 pivot ↓3 7 8 4 2 1 9 5 5 （3）从左到右（除了最后的基准元素），循环移动小于基准元素 5 的所有元素到数组开头，留下大于等于基准元素的元素接在后面。在这个过程它也为基准元素找寻最后摆放的位置。 循环流程如下：循环 i == 0 时，storeIndex == 0，找到一个小于基准元素的元素 3，那么将其与storeIndex 所在位置的元素交换位置，这里是 3 自身，交换后将 storeIndex 自增 1，storeIndex == 1： 12345 pivot ↓3 7 8 4 2 1 9 5 5↑storeIndex 循环 i == 3 时，storeIndex == 1，找到一个小于基准元素的元素 4： 12345 ┌──────┐ pivot ↓ ↓ ↓3 7 8 4 2 1 9 5 5 ↑ ↑storeIndex i 交换位置后，storeIndex 自增 1，storeIndex == 2： 12345 pivot ↓3 4 8 7 2 1 9 5 5 ↑storeIndex 循环 i == 4 时，storeIndex == 2，找到一个小于基准元素的元素 2： 12345 ┌───────┐ pivot ↓ ↓ ↓3 4 8 7 2 1 9 5 5 ↑ ↑storeIndex i 交换位置后，storeIndex 自增 1，storeIndex == 3： 12345 pivot ↓3 4 2 7 8 1 9 5 5 ↑ storeIndex 循环 i == 5 时，storeIndex == 3，找到一个小于基准元素的元素 1： 12345 ┌───────┐ pivot ↓ ↓ ↓3 4 2 7 8 1 9 5 5 ↑ ↑ storeIndex i 交换后位置后，storeIndex 自增 1，storeIndex == 4： 12345 pivot ↓3 4 2 1 8 7 9 5 5 ↑ storeIndex 循环 i == 7 时，storeIndex == 4，找到一个小于等于基准元素的元素 5： 12345 ┌───────────┐ pivot ↓ ↓ ↓3 4 2 1 8 7 9 5 5 ↑ ↑ storeIndex i 交换后位置后，storeIndex 自增 1，storeIndex == 5：12345 pivot ↓3 4 2 1 5 7 9 8 5 ↑ storeIndex （4）循环结束后交换基准元素和 storeIndex 位置的元素的位置： 12345 pivot ↓3 4 2 1 5 5 9 8 7 ↑ storeIndex 那么 storeIndex 的值就是基准元素的最终位置，这样整个分区过程就完成了。 引用维基百科图片 4、代码实现123456789101112131415161718192021222324252627282930313233function quickSort(array) &#123; // 交换元素位置 function swap(array, i, k) &#123; var temp = array[i]; array[i] = array[k]; array[k] = temp; &#125; // 数组分区， 左小右大 function partition(array, left, right) &#123; var storeIndex = left; var pivot = array[right]; // 直接选最右边的元素为基准元素 for (var i = left; i &lt; right; i ++) &#123; if (array[i] &lt; pivot) &#123; swap(array, storeIndex, i); storeIndex ++; // 交换位置后， storeIndex 自增1， 代表下一个可能要交换的位置 &#125; &#125; swap(array, right, storeIndex); // 将基准元素放置到最后的正确位置上 return storeIndex; &#125; function sort(array, left, right) &#123; if (left &gt; right) &#123; return; &#125; var storeIndex = partition(array, left, right); sort(array, left, storeIndex - 1); sort(array, storeIndex + 1, right); &#125; sort(array, 0, array.length - 1); return array;&#125;var arr = [3, 7, 8, 5, 2, 1, 9, 5, 4];console.log(quickSort(arr));]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>前端</tag>
        <tag>Javascript</tag>
        <tag>排序</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Cenos7.2下安装Apache2.4，MySQL5.7和PHP7.1]]></title>
    <url>%2F20190117%2FCenos7.2%E4%B8%8B%E5%AE%89%E8%A3%85Apache2.4%EF%BC%8CMySQL5.7%E5%92%8CPHP7.1.html</url>
    <content type="text"><![CDATA[一、主要软件：1、SecureCRT 5.1：是一款支持SSH（SSH1和SSH2）的终端仿真程序，简单地说是Windows下登录UNIX或Linux服务器主机的软件。 2、WinSCP：是一个Windows环境下使用SSH的开源图形化SFTP客户端。同时支持SCP协议。它的主要功能就是在本地与远程计算机间安全的复制文件。winscp也可以链接其他系统,比如linux系统。 以上两款软件的具体使用可以通过搜索引擎分分钟查到。 二、安装相关软件1、升级yum12yum -y update //升级所有包，改变软件设置和系统设置,系统版本内核都升级yum -y upgrade //升级所有包，不改变软件设置和系统设置，系统版本升级，内核不改变 2、安装Apache2.41yum install -y httpd //安装全新的Apache 打开Apache配置文件： 1vi /etc/httpd/conf/httpd.conf 修改ServerName后面为localhost或者127.0.0.1 启动： 1systemctl start httpd 查看是否启动： 1systemctl status httpd 重启Apache： 1systemctl restart httpd 设置为开机启动 1chkconfig httpd on 3、安装MySQL5.7安装MySQL源： 1yum localinstall http://dev.mysql.com/get/mysql57-community-release-el7-7.noarch.rpm 安装MySQL: 1yum install mysql-community-server 启动: 1systemctl start mysqld 查看状态： 1systemctl status mysqld 获取初始密码： 12grep 'temporary password' /var/log/mysqld.logroot@localhost:后面的就是初始密码 进入MySQL: 1mysql -uroot -p 修改密码： 1ALTER USER 'root'@'localhost' IDENTIFIED BY '你的密码'; //(密码要包含大写，小写，特殊符号，数字等，复杂点最好，不然会报错) 开放远程访问： 123use mysql;update user set host = '%' where user = 'root';// %表示全部放行，也可以设置为特定的ip，比如192.168.25.36。 立即生效： 1flush privileges; 4、安装PHP7.1PHP需要很多依赖包，一般使用源码安装比较好点，先到PHP官网下载php-7.1.12.tar.gz，然后通过winscp上传到/var/src文件夹中，（var文件夹中没有src文件夹的可以通过 mkdir src在var下创建）. 解压PHP压缩包： 1tar -zxvf php-7.1.12.tar.gz 然后进入解压包： 1cd php-7.1.12 安装gcc: 1yum install gcc 安装PHP的依赖包： 12345yum -y install libjpeg libjpeg-devel libpng libpng-devel freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel curl curl-devel openssl openssl-develyum -y install libxslt-devel* yum -y install perl* yum -y install httpd-devel 配置依赖以及php的安装路径： 123456./configure --prefix=/usr/local/php --with-curl --with-freetype-dir --with-gd --with-gettext --with-iconv-dir \--with-kerberos --with-libdir=lib64 --with-libxml-dir --with-mysqli --with-openssl --with-pcre-regex --with-pdo-mysql \--with-pdo-sqlite --with-pear --with-png-dir --with-xmlrpc --with-xsl --with-zlib --enable-fpm --enable-bcmath \-enable-inline-optimization --enable-gd-native-ttf --enable-mbregex --enable-mbstring --enable-opcache --enable-pcntl \--enable-shmop --enable-soap --enable-sockets --enable-sysvsem --enable-xml --enable-zip --enable-pcntl --with-curl \--with-fpm-user=nginx --enable-ftp --enable-session --enable-xml --with-apxs2=/usr/bin/apxs 编译安装： 1make &amp;&amp; make install 配置环境变量： 1vi /etc/profile 在最后面添加： 12PATH=$PATH:/usr/local/php/binexport PATH 改动立即生效： 1source /etc/profile 生成所需文件： 1234cp php.ini-production /usr/local/php/etc/php.inicp sapi/fpm/php-fpm /usr/local/php/etc/php-fpmcp /usr/local/php/etc/php-fpm.conf.default /usr/local/php/etc/php-fpm.confcp /usr/local/php/etc/php-fpm.d/www.conf.default /usr/local/php/etc/php-fpm.d/www.conf 再次修改Apache配置文件： 1vi /etc/httpd/conf/httpd.conf 找到： 12AddType application/x-compress .ZAddType application/x-gzip .gz .tgz 添加： 12AddType application/x-httpd-php .phpAddType application/x-httpd-php-source .php7 找到： 1DirectoryIndex index.html 后面添加index.php: 1DirectoryIndex index.html index.php 在配置的最后添加： 1LoadModule php7_module modules/libphp7.so 最后配置域名： 1234567DocumentRoot /var/www/htmlServerName www.你的域名.comServerAlias 你的域名.comOptions +Indexes +FollowSymLinks +ExecCGIAllowOverride AllOrder Deny,AllowAllow from all 重启Apache。 测试： 在/var/www/html下创建index.php index.php代码： 1phpinfo(); 用域名访问查看打开是不是php配置。 php的配置文件路径：/usr/local/php/etc中]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>服务</tag>
        <tag>Apache</tag>
        <tag>MySQL</tag>
        <tag>Centos7</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[cenos 7下安装SVN以及同步代码到WEB目录]]></title>
    <url>%2F20190117%2Fcenos%207%E4%B8%8B%E5%AE%89%E8%A3%85SVN%E4%BB%A5%E5%8F%8A%E5%90%8C%E6%AD%A5%E4%BB%A3%E7%A0%81%E5%88%B0WEB%E7%9B%AE%E5%BD%95.html</url>
    <content type="text"><![CDATA[一、安装svn1. 运行以下命令安装SVN。1yum install subversion 2.运行以下命令查看SVN版本。1svnserve --version 3. 创建版本库a、 运行以下命令创建目录。 1mkdir /var/svn b、 依次运行以下命令创建版本库。 12cd /var/svnsvnadmin create /var/svn/blog c、 依次运行以下命令查看自动生成的版本库文件。 12cd svnreposls 1234567891011Subversion目录说明：db目录：所有版本控制的数据存放文件。hooks目录：放置hook脚本文件的目录。locks目录：用来追踪存取文件库的客户端。format文件：是一个文本文件，里面只放了一个整数，表示当前文件库配置的版本号。conf目录：是这个仓库的配置文件（仓库的用户访问账号、权限等）。 d、 运行命令cd conf/进入conf目录（该SVN版本库配置文件）。返回结果如下：12345authz：是权限控制文件。passwd：是账号密码文件。svnserve.conf：SVN服务配置文件。 e、 按以下步骤设置账号密码： （1） 运行 vi passwd。 （2） 按 i 键进入编辑模式。 （3） 在 [users] 块中添加用户账号和密码，格式：账号=密码，比如示例中的test= test123（注意等号两端要有一个空格）。 （4） 按 Esc 键退出编辑模式，并输入 :wq 保存并退出。 f、按以下步骤设置权限： （1）运行 vi authz。 （2）按 i 键进入编辑模式。 （3）在末尾添加如下代码（其中，r表示读，w表示写）： 12[/]test=rw （4）按 Esc 键退出编辑模式，并输入 :wq 保存并退出。 g、 按以下步骤修改svnserve.conf文件。 （1）运行命令 vi svnserve.conf。 （2）按 i 键进入编辑模式。 （3）打开以下几个注释（注意每行不能以空格开始，等号两端要有一个空格）：123456789anon-access = read #匿名用户可读，您也可以设置 anon-access = none，不允许匿名用户访问。设置为 none，可以使日志日期正常显示auth-access = write #授权用户可写password-db = passwd #使用哪个文件作为账号文件authz-db = authz #使用哪个文件作为权限文件realm = /var/svn/blog#认证空间名，版本库所在目录 （4）按 Esc 键退出编辑模式，并输入 :wq 保存并退出。 h、运行以下命令启动SVN版本库。 1svnserve -d -r /var/svn/blog g、 运行命令ps -ef |grep svn 查看SVN服务是否开启。 如果返回结果如下图所示，表示SVN服务已经开启。 运行以下命令停止SVN命令。 1killall svnserve 二、在windows上测试1、 在本地机器上安装 TortoiseSVN客户端。 2、 在您的本地项目文件夹，右键空白处弹出菜单，选择 SVN检出。 3、 指定资源库URL，格式为 svn://实例公网IP地址/资源库名；指定检出至目录（如本示例中的D:\WWW\test）；再单击 确定。 如果出现以图所示信息，表示检出成功。 第一次检出需要登录账户和密码，以passwd文件里面的账户密码为主。 三、同步代码到WEB目录1、 运行一下命令进去hooks目录 12cd hooksls 2、 运行以下命令复制post-commit.tmpl 1cp post-commit.tmpl post-commit 3、 添加权限 1chmod 755 post-commit 4、 执行vi post-commit进行编辑，文本最后添加如下代码： 123456789export LANG=en_US.UTF-8 #(注：这里语言不能写成en_us.utf-8，因为Linux中没有这个&gt;小写的语言)echo "Code Deployed at `date "+%Y-%m-%d %H:%M"`" &gt;&gt; /var/svn/yong/hooks/deploy_log#SVN=/var/svn/yong#WEB=/var/www/html #要更新的目录#$SVN update --username yong --password funcpasswd123 $WEBcd /var/www/htmlsvn co file:///var/svn/yong/svn cleanupsvn up /var/www/html/ --username test--password test123 --no-auth-cache 完成以上步骤，即可同步代码到web目录]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Centos7</tag>
        <tag>服务器</tag>
        <tag>Linux</tag>
        <tag>Svn</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关闭apache自动目录列表功能的三种方法]]></title>
    <url>%2F20190117%2F%E5%85%B3%E9%97%ADapache%E8%87%AA%E5%8A%A8%E7%9B%AE%E5%BD%95%E5%88%97%E8%A1%A8%E5%8A%9F%E8%83%BD%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[一、描述：1、当用户访问的网址是某个目录地址的时候，服务器自动显示该目录所包含的文件列表内容。 2、当用户请求的URL地址是某个目录地址的时候，如果该目录开启了自动列表功能并且WEB服务器默认的页面文件(如index.html/home.html/default.htm/index.php等)也不存在， 那么该目录所包含的文件就会被自动的以列表的形式显示出来，这样可能就会导致敏感文件被泄露。 二、危害：1、任何人都可以浏览该目录下的所有文件列表。2、如果该目录不存在默认的主页面文件，并且该目录包含了敏感的文件内容（如应用程序源码文件或其它的重要文件内容），那么将导致敏感文件内容外泄， 从而对企业造成直接的经济损失或为恶意攻击者提供进一步攻击的有效信息。 三、解决方案：1、如果必须开启该目录的目录列表功能，则应对该目录下的文件进行详细检查，确保不包含敏感文件。 2、如非必要，请重新配置WEB服务器，禁止该目录的自动目录列表功能。 Apache禁止列目录： 方法一，修改 httpd.conf 配置文件，查找 Options Indexes FollowSymLinks，修改为 Options -Indexes； 或者 搜索Options Indexes FollowSymLinks，修改为Options -Indexes FollowSymLinks即可。 在Options Indexes FollowSymLinks在Indexes前面加上 – 符号。备注：在Indexes前，加 +代表允许目录浏览；加 –代表禁止目录浏览。这样的话就属于整个Apache禁止目录浏览了。 如果是配置虚拟机，则如下： 方法二，在www 目录下的修改.htaccess配置文件，加入Options -Indexes。 （推荐） 方法三，修改目录配置： 只需要将上面代码中的 Indexes 去掉，就可以禁止 Apache 显示该目录结构。用户就不会看到该目录下的文件和子目录列表了。 Indexes 的作用就是当该目录下没有 index.html 文件时，就显示目录结构，去掉 Indexes ，Apache 就不会显示该目录的列表了。 四、总结1、强烈推荐方法二 2、记得一定重启Apache]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Apache</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Centos7 安装 Nginx+PHP+Mysql]]></title>
    <url>%2F20190117%2FCentos7%20%E5%AE%89%E8%A3%85%20Nginx%2BPHP%2BMysql.html</url>
    <content type="text"><![CDATA[安装Nginx一、安装gccnginx编译依赖gcc环境，centos7上没有gcc环境，则用yum安装gcc: 1yum install gcc-c++ 二、安装pcre pcre-devel是一个perl库，nginx的http模块视图pcre来解析正则表达式： 1yum install -y pcre pcre-devel 三、安装zlibzlib库提供了很多种压缩和解压缩的方式，nginx使用zlib对http包内容进行gzip： 1yum install -y zlib zlib-devel 四、安装OpenSSLOpenSSL是一个安全套接字层密码库，包括主要的密码算法，常用的密钥和证书封装管理功能以及SSL协议： 1yum install -y openssl openssl-devel 五、安装nginx1、下载安装包 官网下载nginx安装包.tar.gz格式，地址：http://nginx.org/en/download.html 2、解压 依次执行如下命令： 12tar -zxvf nginx-1.10.1.tar.gzcd nginx-1.10.1 3、配置 nginx-1.10.1 版本中你就不需要去配置相关东西，默认就可以了，也可以自定义配置目录 a、使用默认设置：1./configure b、自定义配置： 1234567891011121314./configure \--prefix=/usr/local/nginx \--conf-path=/usr/local/nginx/conf/nginx.conf \--pid-path=/usr/local/nginx/conf/nginx.pid \--lock-path=/var/lock/nginx.lock \--error-log-path=/var/log/nginx/error.log \--http-log-path=/var/log/nginx/access.log \--with-http_gzip_static_module \--http-client-body-temp-path=/var/temp/nginx/client \--http-proxy-temp-path=/var/temp/nginx/proxy \--http-fastcgi-temp-path=/var/temp/nginx/fastcgi \--http-uwsgi-temp-path=/var/temp/nginx/uwsgi \--http-scgi-temp-path=/var/temp/nginx/scgi#建议使用第一种配置方式 4、编译安装 1make &amp;&amp; make install 查找安装路径： 1whereis nginx 六，启动、停止nginx1234567cd /usr/local/nginx/sbin/./nginx ./nginx -s stop./nginx -s quit./nginx -s reload./nginx -s quit:此方式停止步骤是待nginx进程处理任务完毕进行停止。./nginx -s stop:此方式相当于先查出nginx进程id再使用kill命令强制杀掉进程。 查询nginx进程： 1ps aux|grep nginx 七、重启nginx1.先停止再启动（推荐）： 对 nginx 进行重启相当于先停止再启动，即先执行停止命令再执行启动命令。如下： 12./nginx -s quit./nginx 2.重新加载配置文件： 当 ngin x的配置文件 nginx.conf 修改后，要想让配置生效需要重启 nginx，使用-s reload不用先停止 ngin x再启动 nginx 即可将配置信息在 nginx 中生效，如下： 1./nginx -s reload 启动成功后，可以在浏览器看到 welcome to nginx 八、设置开机自启动即在rc.local 增加启动代码就行 1vi /etc/rc.local 在最后添加代码： 1/usr/local/nginx/sbin/nginx 设置执行权限 1chmod 755 rc.local 安装php-fpmNginx本身不能处理PHP，作为web服务器，当它接收到请求后，不支持对外部程序的直接调用或者解析，必须通过FastCGI进行调用。 如果是PHP请求，则交给PHP解释器处理，并把结果返回给客户端。PHP-FPM是支持解析php的一个FastCGI进程管理器。 提供了更好管理PHP进程的方式，可以有效控制内存和进程、可以平滑重载PHP配置。 一、安装依赖包1yum install libmcrypt libmcrypt-devel mhash mhash-devel libxml2 libxml2-devel bzip2 bzip2-devel 二、安装php1、下载安装包1地址：http://www.php.net/downloads.php 2、解压安装包 1tar xvf php-7.2.5.tar.bz2 -C /var/src 3、配置 123456789101112131415161718cd /var/src/php-7.2.5./configure --prefix=/usr/local/php7 \--with-config-file-scan-dir=/etc/php.d \--with-config-file-path=/etc \--with-mysql=/usr/local/mysql \--with-mysqli=/usr/local/mysql/bin/mysql_config \--enable-mbstring \--with-freetype-dir \--with-jpeg-dir \--with-png-dir \--with-zlib \--with-libxml-dir=/usr \--with-openssl \-enable-xml \--enable-sockets \--enable-fpm \--with-mcrypt \--with-bz2 4、编译安装 1make &amp;&amp; make install 5、添加php和php-fpm配置文件 1234cp /usr/local/src/php-7.2.5/php.ini-production /etc/php.inicd /usr/local/php7/etc/cp php-fpm.conf.default php-fpm.confsed -i 's@;pid = run/php-fpm.pid@pid = /usr/local/php7/var/run/php-fpm.pid@' php-fpm.conf 6、添加php-fpm启动脚本 12cp /usr/local/src/php-7.2.5/sapi/fpm/init.d.php-fpm /etc/init.d/php-fpmchmod +x /etc/init.d/php-fpm 7、添加php-fpm至服务列表并设置开机自启 123chkconfig --add php-fpm chkconfig --list php-fpm chkconfig php-fpm on 8、启动服务 1service php-fpm start 三、配置nginx对fastcgi的支持1、备份默认的配置文件 1cp /usr/local/nginx/conf/nginx.conf.default /usr/local/nginx/conf/nginx.conf 2、修改配置，支持php格式文件 1vi /usr/local/nginx/conf/nginx.conf 将如下代码的#号删除 12345#default_type application/octet-stream;#log_format main '$remote_addr - $remote_user [$time_local] "$request" '# '$status $body_bytes_sent "$http_referer" '# '"$http_user_agent" "$http_x_forwarded_for"';#access_log logs/access.log main; 将如下代码 1234location / &#123; root html; index index.html index.htm;&#125; 改为： 1234location / &#123; root html; index index.php index.html index.htm;&#125; 将如下代码改为 1234567#location ~ \.php$ &#123;# root html;# fastcgi_pass 127.0.0.1:9000;# fastcgi_index index.php;# fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name;# include fastcgi_params;#&#125; 改为： 12345678location ~ \.php$ &#123; root html; fastcgi_pass 127.0.0.1:9000; fastcgi_index index.php; #fastcgi_param SCRIPT_FILENAME /scripts$fastcgi_script_name; #include fastcgi_params; include fastcgi.conf;&#125; 重新载入nginx的配置文件 12cd /usr/local/nginx/sbin./nginx -s reload 浏览器测试效果 在 /usr/loacl/nginx/html新建index.php,内容如下 1234567$conn=mysqi_connect('127.0.0.1','root','root');if ($conn)&#123; echo "LNMP platform connect to mysql is successful!";&#125;else&#123; echo "LNMP platform connect to mysql is failed!";&#125;phpinfo(); 在浏览器访问测试： 可以输出php配置信息，则配置成功]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>MySQL</tag>
        <tag>Centos7</tag>
        <tag>服务器</tag>
        <tag>Nginx</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[URL设置原则]]></title>
    <url>%2F20190117%2FURL%E8%AE%BE%E7%BD%AE%E5%8E%9F%E5%88%99.html</url>
    <content type="text"><![CDATA[一、为什么需要URL规范化1、为了URI能被方便的录入，写下，拼写和记忆，URI要尽可能的短，根据w3c提供的参考数据，一个URI的长度最好不要超过80个字节。 2、网站URL和结构已经成为网站搜索引擎友好的最大基础性问题，网站URL 和结构问题，早发现早优化，越是往后放，最后就成了制约网站运营和产品开发的决定性因素。 3、无论是网站的可用性还是网站对搜索引擎的吸引力，清晰明了的浏览路径都是相当重要的，URL是统一资源定位，即每个网页的网址、路径。 4、浏览路径让网站的导航结构更清晰，可以更加平衡的分布网站权重。 二、本文将分享URI设计的一些原则 URI的末尾不要添加“/” 多一个斜杠，语义完全不同，究竟是目录，还是资源，还是不确定而多做一次301跳转？ 123负面case：http://api.canvas.com/shapes/ 正面case：http://api.canvas.com/shapes 使用“-”提高URI的可读性 目的是使得URI便于理解，用“-”来连接单词 1正面case：http://api.example.com/blogs/my-first-post 禁止在URL中使用“_” 目的是提高可读性，“_”可能被文本查看器中的下划线特效遮蔽 1负面case：http://api.example.com/blogs/my_first_post 禁止使用大写字母 RFC3986中规定URI区分大小写，但别用大写字母来为难程序员了，既不美观，又麻烦 123负面case：http://api.example.com/My-Folder/My-Doc 正面case：http://api.example.com/my-folder/my-doc 不要在URI中包含扩展名 应鼓励REST API客户端使用HTTP提供的格式选择机制Accept request header 123正面case：http://58.com/bj/ershou/310976一个case：http://58.com/bj/ershou/310976x.shtml]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>Url</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL Limit分页优化]]></title>
    <url>%2F20190117%2FMySQL%20Limit%E5%88%86%E9%A1%B5%E4%BC%98%E5%8C%96.html</url>
    <content type="text"><![CDATA[在对大量数据查询中需要进行分页的时候，我们通常会使用Limit加上偏移量的方法实现， 问题来了，在偏移量非常大的时候，例如可能是limit 10000,10这样的查询，这时MySQL需要查询10010条记录然后只返回最后的10条， 前面10000条记录都被抛弃，造成效率低下。 优化此类分页查询的一个最简单的办法就是尽可能地使用索引覆盖查询，而不是查询所有的列， 然后根据需要做一个关联操作再返回所需的列，对于偏移量很大的时候，这样做的效率会有很大提升。 12SELECT * FROM test LIMIT 900000,10; 慢SELECT * FROM test WHERE id &gt;= ( SELECT id FROM test ORDER BY id LIMIT 900000,1 ) LIMIT 10 快]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>MySQL</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于Windows的FFmpeg+Red5实现海康监控摄像头RTSP协议转RTMP协议的WEB直播]]></title>
    <url>%2F20190117%2F%E5%9F%BA%E4%BA%8EWindows%E7%9A%84FFmpeg%2BRed5%E5%AE%9E%E7%8E%B0%E6%B5%B7%E5%BA%B7%E7%9B%91%E6%8E%A7%E6%91%84%E5%83%8F%E5%A4%B4RTSP%E5%8D%8F%E8%AE%AE%E8%BD%ACRTMP%E5%8D%8F%E8%AE%AE%E7%9A%84WEB%E7%9B%B4%E6%92%AD.html</url>
    <content type="text"><![CDATA[最近公司项目需要，系统中要添加两个海康的监控摄像头，可海康的监控摄像头的数据流是rstp的，在当前的h5页面不能直接使用， 方案一：直接使用必须要用vlc播放器以及火狐支持的vlc的版本（40版支持vlc相对稳定），但是缺点是运行时间久了之后，回报c++运行 库异常的问题， 方案二：同样使用vlc播放器，只是利用lvc播放器进行转码，转成video支持的视频格式，缺点是，延时高，占cup资源。 方案三：使用websocktet转码，使用Streamedian WS RTSP Proxy Server，该软件免费版支持几个监控，方案一、二的问题都可解决， 但是远程访问时websocket会报错，一直没有解决该问题，直接换第四种方案了（时间紧）； 方案四：通过FFmpeg将rtsp协议转成rtmp协议，再用red5流媒体服务器接收和发布rtmp数据，完美解决之前的问题。 以下具体介绍方案四： 所有操作都是windows环境下进行的。 一、安装ffmpeg1、介绍FFmpeg是一套可以用来记录、转换数字音频、视频，并能将其转化为流的开源计算机程序。采用LGPL或GPL许可证。它提供了录制、 转换以及流化音视频的完整解决方案。它包含了非常先进的音频/视频编解码库libavcodec，为了保证高可移植性和编解码质量， libavcodec里很多code都是从头开发的。（百度的） 2、下载ffmpeg1https://ffmpeg.zeranoe.com/builds/ 根据自己的操作系统下载静态程序版本 3、解压文件到指定的磁盘目录结构 4、配置FFmpeg到系统变量在系统变量的path内容中加入d:\ffmpeg\bin;然后确定。 5、cmd测试win+R输入cmd回车打开命令提示符窗口，输入 ffmpeg -version, 如果返回ffmpeg的版本信息，则表示安装成功。 二、安装Red51、安装java由于red5是java开发的，所以安装red5之前要安装java环境，在这里java环境安装不做介绍。具体自行百度。 这里使用的是red5-server-1.0.10，安装jdk1.8即可 2、下载red51https://github.com/Red5/red5-server/releases 3、配置red5到系统变量在系统变量中加入 red5解压的目录地址即可 4、测试在命令提示符窗口输入red5，有信息输入则表示安装成功 默认端口是5080，可在浏览器输入127.0.0.1:5080访问 若修改配置可以看具体的文档介绍。 三、主要问题，转协议主要代码 123ffmpeg -i "rtsp://admin:admin123@10.10.10.158/h264/ch1/main/av_stream" -f flv -r 25 -s 640x480 -an "rtmp://localhost/oflaDemo/hello"rtsp://admin:admin123@10.10.10.158/h264/ch1/main/av_stream 海康监控的地址rtmp://localhost/oflaDemo/hello 转协议后的地址 修改Red5安装目录下的 webapps\oflaDemo\index.html 文件，将jwplayer的 file 属性改成 “hello”。 访问 http://localhost:5080/oflaDemo/index.html 在你所修改的播放器上是否可以看到摄像头的直播了。 同样把index.html的关键代码放到项目中就成了，就搞定了。 参考：1http://www.cuplayer.com/player/PlayerCode/RTSP/2014/0706/1419.html]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>web</tag>
        <tag>监控</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Yii2获取模块名、控制器名、方法名]]></title>
    <url>%2F20190117%2FYii2%E8%8E%B7%E5%8F%96%E6%A8%A1%E5%9D%97%E5%90%8D%E3%80%81%E6%8E%A7%E5%88%B6%E5%99%A8%E5%90%8D%E3%80%81%E6%96%B9%E6%B3%95%E5%90%8D%20.html</url>
    <content type="text"><![CDATA[在Yii2获取模块名、控制器名、方法名 在控制器中： 1234567模块名 Yii::$app-&gt;controller-&gt;module-&gt;id;控制器名 Yii::$app-&gt;controller-&gt;id方法名 Yii::$app-&gt;controller-&gt;action-&gt;id; 或者模块名 $this-&gt;module-&gt;id;控制器名 $this-&gt;id;方法名 $this-&gt;action-&gt;id; 在视图中： 123模块名 $this-&gt;context-&gt;module-&gt;id控制器名 $this-&gt;context-&gt;id方法名 $this-&gt;context-&gt;action-&gt;id 做权限判断可在控制器的beforeAction方法中，在$action参数中获取 123模块名 $action-&gt;controller-&gt;module-&gt;id;控制器名 $action-&gt;controller-&gt;id;方法名 $action-&gt;id;]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Yii2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Win系统下配置PHP链接Oracle]]></title>
    <url>%2F20190117%2FWin%E7%B3%BB%E7%BB%9F%E4%B8%8B%E9%85%8D%E7%BD%AEPHP%E9%93%BE%E6%8E%A5Oracle.html</url>
    <content type="text"><![CDATA[一、环境1Apahce2.4 php5.6 Oracle 11&lt;/code&gt;&lt;/pre&gt; 二、修改php.ini配置 php.ini中启用php_oci8_11g.dll，如果使用pdo，就将php_pdo_oci.dll也启用； 三、 下载instantclient_12_1 环境是32位的下载32的，64位的下载64位的 四、系统变量配置 将instantclient_12_1的路径配置到系统变量，并将目录下的oci.dll 复制到C:\Windows\SysWOW64； 五、重启apache 查看phpinfo(),看下PDO扩展中是否存在oci以及是否存在PDO_OCI扩展， 若存在则说明配置成功 2019年2月16日更新六、32位win系统配置Oracle问题 1、下载Oracle client 根据系统位数和php位数下载响应的Oracle client 1232位下载链接：http://www.oracle.com/technetwork/cn/topics/winsoft-085727.html64位下载链接：http://www.oracle.com/technetwork/topics/winx64soft-_089540.html 2、配置环境变量 下载后把instantclient_11_2 目录配置到系统环境变量中(D:/instantclient_11_2) 3、然后把instantclient_11_2目录下的oci.dll，oraociei11.dll，orannzsbb11.dll这三个文件放到C:\Window\System32系统文件目录下 4、找到php的配置文件php.ini文件，打开并找到extension=php_oci8.dll、extension=php_pdo_oci.dll、extension=php_pdo_odbc.dll 5、最后重启apache服务，通过phpinfo()函数查看是否开启了OCI扩展。]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>Oracle</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PHP防止sql注入，XSS攻击简单方法]]></title>
    <url>%2F20190117%2FPHP%E9%98%B2%E6%AD%A2sql%E6%B3%A8%E5%85%A5%EF%BC%8CXSS%E6%94%BB%E5%87%BB%E7%AE%80%E5%8D%95%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[实际项目部署到公网上，为防止恶意的操作，后端对数据已进行一系列的验证，有效的提高网站安全性。 sql注入，xss攻击常见的攻击防止，本文章介绍防止sql注入，xss攻击，废话不多说，直接上代码 （代码尽供参考，各有各的想法） 123456789101112131415161718/** * [actionClean xss攻击] * @Author My * @DateTime 2018-09-19T10:47:15+0800 * @param [type] $str [description] * @return [type] [description] */public function clearXSS($str)&#123; $str = trim($str); $str = strip_tags($str);//剥去字符串中的 HTML、XML 以及 PHP 的标签。 $str = stripslashes($str);//由 addslashes() 函数添加的反斜杠。 $str = addslashes($str);//在预定义字符之前添加反斜杠的字符串。 $str = rawurldecode($str);//对已编码的 URL 字符串进行解码 $str = quotemeta($str);//在预定义字符前添加反斜杠： $str = htmlspecialchars($str);//预定义的字符 "&lt;" （小于）和 "&gt;" （大于）转换为 HTML 实体： return $str;&#125; 12345678910111213141516171819/** * [clearFilterWords 清除sql关键字 特殊字符等] * @Author My * @DateTime 2018-09-19T12:15:37+0800 * @param [type] $str [description] * @return [type] [description] */public function clearFilterWords($str)&#123; $farr = array( "/&lt;(\\/?)(script|i?frame|style|html|body|title|link|meta|object|\\?|\\%)([^&gt;]*?)&gt;/isU", "/(&lt;[^&gt;]*)on[a-zA-Z]+\s*=([^&gt;]*&gt;)/isU", "/select|insert|update|delete|drop|\'|\/\*|\*|\+|\-|\"|\.\.\/|\.\/|union|into|load_file|outfile|dump/is", "/\/|\~|\!|\@|\#|\\$|\%|\^|\&amp;|\*|\(|\)|\_|\+|\&#123;|\&#125;|\:|\&lt;|\&gt;|\?|\[|\]|\,|\.|\/|\;|\'|\`|\-|\=|\\\|\|/", "/\s/", ); $str = preg_replace($farr, '', $str);//去除特殊字符 $str = $this-&gt;clearXSS($str); return $str;&#125; 调用方法： 12345678910111213141516171819/** * [checkXSSSqlInject 防止注入 xss攻击调用方法] * @Author My * @DateTime 2018-09-19T12:15:05+0800 * @param [type] $params [description] * @return [type] [description] */public function checkXSSSqlInject(&amp;$params)&#123; if(is_array($params))&#123; foreach($params as $k =&gt; $v)&#123; $params[$k] = $this-&gt;clearFilterWords($v); &#125; &#125;else&#123; $params = $this-&gt;clearFilterWords($params); &#125; return $params;&#125;//调用$this-&gt;checkXSSSqlInject($params);]]></content>
      <categories>
        <category>PHP</category>
      </categories>
      <tags>
        <tag>PHP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《MongoDB权威指南》之MongoDB初探]]></title>
    <url>%2F20190117%2F%E3%80%8AMongoDB%E6%9D%83%E5%A8%81%E6%8C%87%E5%8D%97%E3%80%8B%E4%B9%8BMongoDB%E5%88%9D%E6%8E%A2.html</url>
    <content type="text"><![CDATA[基本概念文档是MongoDb中数据的基本单元。非常类似于关系数据库管理系统中的行（但是比行要复杂的多） 类似低，集合可以被看做是没有模式的表 MongoDb的单个实例可以容纳多个独立的数据库，每一个都有自己的集合和权限 MongoDB自带简洁但功能强大的JavaScript Shell，这个工具对于管理MongoDB实例和操作数据作用非常大 每一个文档都有一个特殊的建_id，它在文档所处的集合中是唯一的 1、文档文档的建是字符串。 键不能含有\0（空字符），这个字符用来表示键的结尾 .和$有特别的意义，只有在特定环境下才能使用。 以下划线‘_’开头的键是保留的。 MongoDB不但区分类型，也区分大小写 123456类型： &#123;'foo':3&#125; &#123;'foo': '3'&#125;大小写： &#123;'foo':3&#125; &#123;'FOO':3&#125; 不能有重复的键 如下文档是非法的： 1&#123;'a':'Hello', 'a':'Word'&#125; 2、集合集合就是一组文档，如果说MongoDB中的文档类似于关系型数据库中的行，那么集合就如同表 2.1、无模式集合是无模式的， 2.2、命名1234集合名不能是空字符串''。集合名不能含有\0（空字符）集合名不能以‘system.’开头，装饰为系统集合保留的前缀用户创建的集合名不能含有保留字符$ 2.3、数据库123456多个集合组成数据库数据库名命名规则：不能是空字符串（''）不能含有''（空格）、.、$、/、\和\0.应全部小写最多64字节 2.4、启动mongodbWindows下启动： 1$ mongod.exe 2.5 MongoDB Shell2.5.1、运行shell1$./mongo shell可以利用javaScript标准库 可以定义调用javaScript函数 2.5.3、shell中的基本操作4个基本操作：创建、读取、更新和删除（CRUD） 1、创建insert 函数添加一个文档到集合里面 123456post = &#123; title:'test', content:'test context', date:new Date()&#125;db.blog.insert(post) 2、读取12db.blog.find()返回所有的文档db.blog.findOne()查看一个文档 3、更新update 接收（至少）两个参数 第一个是要更新文档的限定条件， 第二个是新的文档 12post.comments = []db.blog.update(&#123;title:222&#125;, post) 4、删除remove用来从数据库中永久的删除文档 1bd.blog.remove(&#123;title:'test'&#125;) 2.6、数据类型2.6.1、基本数据类型a、null 用于表示空值或者不存在的字段 1&#123;'x':null&#125; b、布尔 布尔类型有两个值’true’和’false’： 1&#123;'x':true&#125; c、32位整数 shell中不可用， javaScript仅支持64位浮点数， 所以32位整数会被自动转换 d、64位整数 shell也不支持该类型。shell会使用一个特殊的内嵌文档来显示64位整数 e、64位浮点数 shell中的数字都是这个类型 12&#123;'X':3.15&#125;&#123;'X':3&#125; 都是浮点数 f、字符串 utf-8字符串都可表示为字符串类型的数据： 1&#123;'x':'foobar'&#125; g、符号： shell不支持该类型，shell将数据库里面的符号类型转成字符串 h、对象id： 对象id是文档的唯一id 1&#123;'x':objectId()&#125; i、日期: 日期类型存储的是从标准纪元开始的毫秒数。不存储时区： 1&#123;'x':new Date()&#125; j、正则表达式： 文档中可以包含正则表达式，采用javaScript的正则表达式语法 1&#123;'x':/foovar/i&#125; k、代码： 文档中还可以包含javaScript代码： 1&#123;'X':function()&#123;/*....*/&#125;&#125; l、二进制数据： 二进制数据可以由任意字节的串组成，不过shell中无法使用 m、最大值： BSON包含一个特殊类型。表示可能的最大值，shell中没有这个类型 n、最小值： BSON包含一个特殊类型，表示可能的最下值，shell中没有这个类型 o、未定义： 文档中也可以使用未定义类型（javaScript中的null和undefined是不同的类型） 1&#123;'x':undefined&#125; p、数组： 值的集合或者列表可以表示成数组 1&#123;'x':['a','b','c']&#125; q、内嵌文档： 文档可以包含别的文档，也可以作为值嵌入到父文档中 1&#123;'x':&#123;'foo':'bar'&#125;&#125; 该内容由阅读《MongoDB权威指南》整理。]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
        <tag>MongoDB</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python基础整理之if、while、for]]></title>
    <url>%2F20190117%2FPython%E5%9F%BA%E7%A1%80%E6%95%B4%E7%90%86%E4%B9%8Bif%E3%80%81while%E3%80%81for.html</url>
    <content type="text"><![CDATA[一、if-else代码格式 1234if 条件: 满足条件时else: 不满足条件时 栗子： 1234567chePiao = 1 # 用1代表有车票，0代表没有车票if chePiao == 1: print("有车票，可以上火车") print("终于可以见到Ta了，美滋滋~~~")else: print("没有车票，不能上车") print("亲爱的，那就下次见了，一票难求啊") 运行结果 12有车票，可以上火车终于可以见到Ta了，美滋滋~~~ 二、elif代码格式： 123456if 满足1: 事情1elif 满足2: 事情2elif 满足3: 事情3 案例： 1234567891011score = 77if score&gt;=90 and score&lt;=100: print('本次考试，等级为A')elif score&gt;=80 and score&lt;90: print('本次考试，等级为B')elif score&gt;=70 and score&lt;80: print('本次考试，等级为C')elif score&gt;=60 and score&lt;70: print('本次考试，等级为D')elif score&gt;=0 and score&lt;60: print('本次考试，等级为E') 运行结果 1本次考试，等级为C 和else一起使用 格式： 123456if 满足1: 事情1elif 满足2: 事情2else 其他事情 三、if嵌套格式： 1234if 条件1： 满足条件1。。。。 if 条件2: 满足条件2。。。 案例： 1234567891011chePiao = 1 # 用1代表有车票，0代表没有车票daoLenght = 9 # 刀子的长度，单位为cmif chePiao == 1: print("有车票，可以进站") if daoLenght &lt; 10: print("通过安检") else: print("没有通过安检") print("刀子的长度超过规定，等待警察处理...")else: print("没有车票，不能进站") 运行结果 12有车票，可以进站通过安检 情节描述：上公交车，并且可以有座位坐下 要求：输入公交卡当前的余额，只要超过2元，就可以上公交车；如果空座位的数量大于0，就可以坐下 代码： 12345678910money = 10seatCount = 0if money &gt; 2: print("可以上车") if(seatCount &gt; 0): print("可以坐下") else: print("不可以坐下")else: print("不可以上车") 运行结果 12可以上车不可以坐下 四、while循环格式： 12while 条件: 满足条件。。。。 案例: 12345i =0while i &lt; 3: print("当前是第%d次执行循环"%(i+1)) print("i=%d"%i) i+=1 运行结果： 123456当前是第1次执行循环i=0当前是第2次执行循环i=1当前是第3次执行循环i=2 五、while循环的应用1、计算1-100的累加和 123456i = 1sum = 0while i &lt;= 100: sum = sum + i i += 1print('1~100的累加和为：%d'%sum) 运行结果： 1-100的累加和为：5050 2、计算1~100之间偶数的累加和 1234567i = 1sum = 0while i &lt;= 100: if i % 2 == 0: sum = sum + i i += 1print('1-100的偶数累加和：%d'%sum) 运行结果： 11-100的偶数累加和：2550 六、while循环的嵌套格式： 1234while 条件1: 满足条件1。。。。 while 条件2： 满足条件2。。。 案例一：打印如下图形123456** ** * ** * * ** * * * * 代码块： 12345678i = 1while i &lt;= 5: j = 1 while j &lt;= i: print('* ', end= '') j += 1 print('\n') i += 1 案例二：九九乘法表 12345678i = 1while i &lt;= 9: j = 1 while j &lt;= i: print('%d*%d=%-4d'%(j, i, i * j), end='') j += 1 print('\n') i += 1 运行结果： 12345678910111213141516171*1=11*2=2 2*2=41*3=3 2*3=6 3*3=91*4=4 2*4=8 3*4=12 4*4=161*5=5 2*5=10 3*5=15 4*5=20 5*5=251*6=6 2*6=12 3*6=18 4*6=24 5*6=30 6*6=361*7=7 2*7=14 3*7=21 4*7=28 5*7=35 6*7=42 7*7=491*8=8 2*8=16 3*8=24 4*8=32 5*8=40 6*8=48 7*8=56 8*8=641*9=9 2*9=18 3*9=27 4*9=36 5*9=45 6*9=54 7*9=63 8*9=72 9*9=81 七、for循环格式： 1234for 临时变量 in 列表或者字符串等： 循环满足条件。。。else 不满足条件执行 案例一 123str = 'hello word'for i in str: print(i) 结果： 12345678910helloword 八、break和continue11、break for循环带入break 案例 123456name = 'dongGe' for x in name: print('----') if x == 'g': break print(x) 运行结果： 1234567----d----o----n---- while循环带入break 案例 1234567i = 0while i &lt; 10: i = i + 1 print('----') if i == 5: break print(i) 运行结果 123456789----1----2----3----4---- 小结 break的作用：用来结束整个循环 2、continue for循环带入continue 实例 123456name = 'dongGe'for x in name: print('----') if x == 'g': continue print(x) 运行结果： 1234567891011----d----o----n--------G----e while循环带入continue 实例 1234567i = 0while i&lt;10: i = i+1 print('----') if i==5: continue print(i) 运行结果： 12345678910111213141516171819----1----2----3----4--------6----7----8----9----10 小结：continue的作用：用来结束本次循环，紧接着执行下一次的循环]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Python整理之字符串操作]]></title>
    <url>%2F20190117%2FPython%E6%95%B4%E7%90%86%E4%B9%8B%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C.html</url>
    <content type="text"><![CDATA[如有字符串 mystr = &#39;I am learning python string operation python.&#39;，以下是常见的操作 1、find语法： 1mystr.find(str, start=0, end=len(mystr)) 检测 str 是否包含在 mystr中，如果是返回开始的索引值，否则返回-1 实例： 12print(mystr.find('Python'))#14print(mystr.find('Python', 0, 10))#-1 2、rfind类似于find()函数 ，不过是从右边开始查找 1mystr.rfind(str, start=0,end=len(mystr)) 实例： 12print(mystr.rfind('python'))#38print(mystr.rfind('python', 0, 10))#-1 3、index跟find()方法一样，只不过如果str不在 mystr中会报一个异常. 1mystr.index(str, start=0, end=len(mystr)) 实例： 1print(mystr.index('Python', 0, 10)) 异常： 1234Traceback (most recent call last): File "i:/Python学习/字符串str.py", line 5, in print(mystr.index('Python', 0, 10))ValueError: substring not found 4、rindex类似于 index()，不过是从右边开始. 1mystr.rindex( str, start=0,end=len(mystr)) 实例： 1print(mystr.rindex('Python', 0, 10)) 异常： 1234Traceback (most recent call last): File "i:/Python学习/字符串str.py", line 6, in print(mystr.rindex('Python', 0, 10))ValueError: substring not found 5、count返回 str在start和end之间 在 mystr里面出现的次数 1mystr.count(str, start=0, end=len(mystr)) 实例： 1print(mystr.count('on'))#3 6、replace把 mystr 中的 str1 替换成 str2,如果 count 指定，则替换不超过 count 次. 1mystr.replace(str1, str2, mystr.count(str1)) 实例： 1print(mystr.replace('python', 'Python', mystr.count('python'))) 结果： 1I am learning Python string operation Python. 7、split1mystr.split(str="", num=string.count(str)) 以 str 为分隔符切片 mystr，如果 num 有指定值，则仅分隔 num 个子字符串 实例： 12print(mystr.split(' '))print(mystr.split(' ', 2)) 结果： 12['I', 'am', 'learning', 'python', 'string', 'operation', 'python.']['I', 'am', 'learning python string operation python.'] 8、capitalize1mystr.capitalize() 把字符串的第一个字符大写 实例： 12mystr = 'i am learning python string operation python.'print(mystr.capitalize()) 结果： 1I am learning python string operation python. 9、title12345678mystr.title()``````python把字符串的每个单词首字母大写实例：```pythonprint(mystr.title()) 结果： 1I Am Learning Python String Operation Python. 10、startswith1mystr.startswith(obj) 检查字符串是否是以 obj 开头, 是则返回 True，否则返回 False 实例： 12print(mystr.startswith('I'))print(mystr.startswith('i')) 结果： 12TrueFalse 11、endswith1mystr.endswith(obj) 检查字符串是否以obj结束，如果是返回True,否则返回 False 实例： 12print(mystr.endswith('python.'))print(mystr.endswith('Python.')) 结果： 12TrueFalse 12、lower1mystr.lower() 转换 mystr 中所有大写字符为小写 实例： 12mystr = 'I AM LEARNING PYTHON STRING OPERATION PYTHON.'print(mystr.lower()) 结果： 1i am learning python string operation python. 13、upper1mystr.upper() 转换 mystr 中的小写字母为大写 实例： 12mystr = 'i am learning python string operation python.'print(mystr.upper()) 结果： 1I AM LEARNING PYTHON STRING OPERATION PYTHON. 14、ljust1mystr.ljust(width) 返回一个原字符串左对齐,并使用空格填充至长度 width 的新字符串 实例： 123mystr = 'Hello'print(len(mystr))print(len(mystr.ljust(10))) 结果： 返回字符串长度可明显看出效果 12510 15、rjust1mystr.rjust(width) 返回一个原字符串右对齐,并使用空格填充至长度 width 的新字符串 实例： 123mystr = 'Hello'print(mystr.rjust(10))print(len(mystr.rjust(10))) 结果： 12 Hello10 16、center1mystr.center(width) 返回一个原字符串居中,并使用空格填充至长度 width 的新字符串 实例： 12mystr = 'Hello'print(mystr.center(25)) 结果： 1Hello 17、lstrip1mystr.lstrip() 删除 mystr 左边的空白字符 实例： 12mystr = ' Hello 'print(mystr.lstrip()) 结果： 1Hello 18、rstrip1mystr.rstrip() 删除 mystr 字符串末尾的空白字符 实例： 12mystr = ' Hello 'print(mystr.rstrip()) 结果： 1Hello 19、strip1mystr.strip() 删除mystr字符串两端的空白字符 实例： 12mystr = ' Hello 'print(mystr.strip()) 结果： 1Hello 20、partition1mystr.partition(str) 把mystr以str分割成三部分,str前，str和str后 实例： 12mystr = 'i am learning python string operation python.'print(mystr.partition('string')) 结果： 1('i am learning python ', 'string', ' operation python.') 21、rpartition1mystr.rpartition(str) 类似于 partition()函数,不过是从右边开始. 实例： 12mystr = 'i am learning python string operation string python.'print(mystr.rpartition('string')) 结果： 1('i am learning python string operation ', 'string', ' python.') 22、splitlines1mystr.splitlines() 按照行分隔，返回一个包含各行作为元素的列表 实例： 12mystr = 'i am learning python \nstring operation string python.'print(mystr.splitlines()) 结果： 1['i am learning python ', 'string operation string python.'] 23、isalpha1mystr.isalpha() 如果 mystr 所有字符都是字母 则返回 True,否则返回 False 实例： 123456mystr = 'Hello'print(mystr.isalpha())mystr = '12345'print(mystr.isalpha())mystr = 'abc 123'print(mystr.isalpha()) 结果： 123TrueFalseFalse 24、isdigit1mystr.isdigit() 如果 mystr 只包含数字则返回 True 否则返回 False. 实例： 123456mystr = 'Hello'print(mystr.isdigit())mystr = '12345'print(mystr.isdigit())mystr = 'abc 123'print(mystr.isdigit()) 结果： 123FalseTrueFalse 25、isalnum1mystr.isalnum() 如果 mystr 所有字符都是字母或数字则返回 True,否则返回 False 实例： 12345678mystr = 'Hello'print(mystr.isalnum())mystr = '12345'print(mystr.isalnum())mystr = 'abc123'print(mystr.isalnum())mystr = 'abc 123'print(mystr.isalnum()) 结果： 1234TrueTrueTrueFalse 26、isspace1mystr.isspace() 如果 mystr 中只包含空格，则返回 True，否则返回 False. 实例： 12345678mystr = 'Hello'print(mystr.isspace())mystr = ''print(mystr.isspace())mystr = ' 'print(mystr.isspace())mystr = 'abc 123'print(mystr.isalnum()) 结果： 1234FalseFalseTrueFalse 27、join1mystr.join(str) mystr 中每个字符后面插入str,构造出一个新的字符串 实例： 12345str = ' 'li = ['I', 'am', 'learning', 'python', 'string', 'operation', 'python.']print(str.join(li))str = '_'print(str.join(li)) 结果：12I am learning python string operation python.I_am_learning_python_string_operation_python.]]></content>
      <categories>
        <category>Python</category>
      </categories>
      <tags>
        <tag>Python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL数据库字典导出功能]]></title>
    <url>%2F20190117%2FMySQL%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%97%E5%85%B8%E5%AF%BC%E5%87%BA%E5%8A%9F%E8%83%BD.html</url>
    <content type="text"><![CDATA[由于项目需求会经常发生变化，导致数据库数据表可能结构上发生变化，这样可能会导致数据库字段说明文档跟数据库字段不一致问题， 同步更新文档又浪费时间，还不如直接将数据库导出成数据库字典不就完了，简单不费时。 主要数据库字典生成的SQL语句： 主要的程序代码是用PHP完成的，具体如下： 创建PDO连接MySQL实例： 1234567try &#123; $this-&gt;conn = new PDO("mysql:host=&#123;$this-&gt;host&#125;;port=&#123;$this-&gt;port&#125;;dbname=information_schema", $this-&gt;user, $this-&gt;passwd, $this-&gt;driver_options); $this-&gt;conn-&gt;setAttribute(PDO::ATTR_ERRMODE, PDO::ERRMODE_EXCEPTION);&#125;catch(PDOException $e)&#123; echo $e-&gt;getMessage();&#125; 利用PDO预处理查询数据： 123$result = $this-&gt;conn-&gt;prepare($sql);//准备查询语句$result-&gt;execute();//执行查询语句，并返回结果集$this-&gt;data = $result-&gt;fetchAll(PDO::FETCH_ASSOC);//获取结果集中的所有数据 设置导出文件头信息： 导出生成数据库字典word文档： 12345678910if (strpos($_SERVER["HTTP_USER_AGENT"], 'MSIE')) &#123; header("Content-Disposition: attachment; filename=&#123;$this-&gt;database&#125;数据字典.doc"); &#125;else if (strpos($_SERVER["HTTP_USER_AGENT"], 'Firefox')) &#123; header("Content-Disposition: attachment; filename=&#123;$this-&gt;database&#125;数据字典.doc"); &#125; else &#123; header("Content-Disposition: attachment; filename=&#123;$this-&gt;database&#125;数据字典.doc"); &#125; header("Pragma:no-cache"); //不能被浏览器缓存 header("Expires:0"); //页面从浏览器高速缓存到期的时间分钟数，设定expires属性为0，将使对一页面的新的请求从服务器产生ob_end_flush();//输出全部内容到浏览器]]></content>
      <categories>
        <category>Mysql</category>
      </categories>
      <tags>
        <tag>PHP</tag>
        <tag>MySQL</tag>
      </tags>
  </entry>
</search>
